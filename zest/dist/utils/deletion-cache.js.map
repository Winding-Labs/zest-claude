{
  "version": 3,
  "sources": ["../src/utils/deletion-cache.ts", "../src/config/constants.ts", "../src/utils/logger.ts"],
  "sourcesContent": [
    "/**\r\n * Deletion cache manager\r\n *\r\n * Stores file content before deletion (PreToolUse) so it can be used\r\n * to generate diffs after deletion (PostToolUse)\r\n */\r\n\r\nimport { mkdir, readdir, readFile, rm, stat, writeFile } from \"node:fs/promises\";\r\nimport { join } from \"node:path\";\r\nimport { DELETION_CACHE_DIR, DELETION_CACHE_TTL_MS } from \"../config/constants.js\";\r\nimport { logger } from \"./logger.js\";\r\n\r\ninterface CachedDeletion {\r\n  filePath: string;\r\n  content: string;\r\n  timestamp: number;\r\n  sessionId: string;\r\n}\r\n\r\n/**\r\n * Initialize cache directory\r\n */\r\nasync function ensureCacheDir(): Promise<void> {\r\n  try {\r\n    await mkdir(DELETION_CACHE_DIR, { recursive: true });\r\n  } catch (error) {\r\n    logger.error(\"Failed to create cache directory:\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * Generate cache key from file path and session\r\n */\r\nfunction getCacheKey(filePath: string, sessionId: string): string {\r\n  // Use simple hash of filepath to avoid filesystem issues\r\n  const hash = Buffer.from(filePath).toString(\"base64\").replace(/[/+=]/g, \"_\");\r\n  return `${sessionId}_${hash}.json`;\r\n}\r\n\r\n/**\r\n * Store file content before deletion\r\n */\r\nexport async function cacheFileForDeletion(\r\n  filePath: string,\r\n  content: string,\r\n  sessionId: string,\r\n): Promise<void> {\r\n  try {\r\n    await ensureCacheDir();\r\n\r\n    const cached: CachedDeletion = {\r\n      filePath,\r\n      content,\r\n      timestamp: Date.now(),\r\n      sessionId,\r\n    };\r\n\r\n    const cacheKey = getCacheKey(filePath, sessionId);\r\n    const cachePath = join(DELETION_CACHE_DIR, cacheKey);\r\n\r\n    await writeFile(cachePath, JSON.stringify(cached, null, 2), \"utf-8\");\r\n    logger.debug(`Cached file content: ${filePath} (${content.length} chars)`);\r\n  } catch (error) {\r\n    logger.error(`Failed to cache file for deletion: ${filePath}`, error);\r\n  }\r\n}\r\n\r\n/**\r\n * Retrieve cached file content for diff generation\r\n * Removes the cache entry after retrieval\r\n */\r\nexport async function getCachedFileContent(\r\n  filePath: string,\r\n  sessionId: string,\r\n): Promise<string | null> {\r\n  try {\r\n    const cacheKey = getCacheKey(filePath, sessionId);\r\n    const cachePath = join(DELETION_CACHE_DIR, cacheKey);\r\n\r\n    try {\r\n      const content = await readFile(cachePath, \"utf-8\");\r\n      const cached: CachedDeletion = JSON.parse(content);\r\n\r\n      // Check if cache is still valid (not expired)\r\n      const age = Date.now() - cached.timestamp;\r\n\r\n      if (age > DELETION_CACHE_TTL_MS) {\r\n        logger.debug(`Cache expired for ${filePath} (${age}ms old)`);\r\n        await rm(cachePath).catch(() => {}); // Clean up expired cache\r\n        return null;\r\n      }\r\n\r\n      // Clean up cache after retrieval\r\n      await rm(cachePath).catch(() => {});\r\n\r\n      logger.debug(`Retrieved cached content for ${filePath} (${cached.content.length} chars)`);\r\n      return cached.content;\r\n    } catch (readError) {\r\n      // Cache file doesn't exist\r\n      logger.debug(`Cache not found for ${filePath}`);\r\n      return null;\r\n    }\r\n  } catch (error) {\r\n    logger.error(`Failed to retrieve cached content: ${filePath}`, error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Clean up old cache entries\r\n * Called periodically to prevent cache buildup\r\n */\r\nexport async function cleanupOldCache(): Promise<void> {\r\n  try {\r\n    await ensureCacheDir();\r\n    const files = await readdir(DELETION_CACHE_DIR);\r\n    const now = Date.now();\r\n\r\n    for (const file of files) {\r\n      try {\r\n        const filePath = join(DELETION_CACHE_DIR, file);\r\n        const stats = await stat(filePath);\r\n\r\n        // Delete files older than TTL\r\n        const age = now - stats.mtimeMs;\r\n        if (age > DELETION_CACHE_TTL_MS) {\r\n          await rm(filePath);\r\n          logger.debug(`Cleaned up old cache entry: ${file} (${age}ms old)`);\r\n        }\r\n      } catch (error) {\r\n        // Ignore errors for individual files\r\n        logger.debug(`Failed to clean up cache file ${file}:`, error);\r\n      }\r\n    }\r\n  } catch (error) {\r\n    logger.error(\"Failed to cleanup old cache:\", error);\r\n  }\r\n}\r\n",
    "/**\r\n * Application constants and configuration values\r\n */\r\n\r\nimport { homedir } from \"node:os\";\r\nimport { join } from \"node:path\";\r\n\r\n// Base directories\r\nexport const CLAUDE_ZEST_DIR = join(\r\n  homedir(),\r\n  `.claude-zest${process.env.NODE_ENV === \"development\" ? \"-dev\" : \"\"}`,\r\n);\r\nexport const QUEUE_DIR = join(CLAUDE_ZEST_DIR, \"queue\");\r\nexport const LOGS_DIR = join(CLAUDE_ZEST_DIR, \"logs\");\r\nexport const STATE_DIR = join(CLAUDE_ZEST_DIR, \"state\");\r\nexport const DELETION_CACHE_DIR = join(CLAUDE_ZEST_DIR, \"cache\", \"deletions\");\r\n\r\n// File paths\r\nexport const SESSION_FILE = join(CLAUDE_ZEST_DIR, \"session.json\"); // Auth session + workspace info\r\nexport const SETTINGS_FILE = join(CLAUDE_ZEST_DIR, \"settings.json\"); // User preferences\r\nexport const LOG_FILE = join(LOGS_DIR, \"plugin.log\");\r\nexport const SYNC_LOG_FILE = join(LOGS_DIR, \"sync.log\");\r\nexport const DAEMON_PID_FILE = join(CLAUDE_ZEST_DIR, \"daemon.pid\");\r\n\r\n// Queue files\r\nexport const EVENTS_QUEUE_FILE = join(QUEUE_DIR, \"events.jsonl\");\r\nexport const SESSIONS_QUEUE_FILE = join(QUEUE_DIR, \"chat-sessions.jsonl\");\r\nexport const MESSAGES_QUEUE_FILE = join(QUEUE_DIR, \"chat-messages.jsonl\");\r\n\r\n// Platform and source identifiers\r\nexport const PLATFORM = \"terminal\";\r\nexport const SOURCE = \"claude-code\";\r\nexport const CLIENT_ID = \"claude-cli\";\r\n\r\n// Sync configuration\r\nexport const SYNC_INTERVAL_MS = 60000; // 60 seconds\r\nexport const MAX_RETRY_ATTEMPTS = 3;\r\nexport const RETRY_BACKOFF_MS = 5000;\r\n\r\n// File locking configuration\r\nexport const LOCK_RETRY_MS = 50; // Retry interval when lock is held by another process\r\nexport const LOCK_MAX_RETRIES = 300; // Max retries (10 seconds total)\r\n\r\n// Debounce configuration (prevents duplicate hook executions)\r\nexport const DEBOUNCE_DIR = join(CLAUDE_ZEST_DIR, \"debounce\");\r\nexport const DEBOUNCE_WINDOW_MS = 500; // First-wins debounce window\r\nexport const DEBOUNCE_TRAILING_MS = 300; // Trailing debounce: wait after last hook before processing\r\n\r\n// Delayed extraction configuration (for PostToolUse trailing debounce)\r\nexport const DELAYED_EXTRACTION_INITIAL_DELAY_MS = 500; // Initial wait before checking if hooks settled\r\nexport const DELAYED_EXTRACTION_MAX_WAIT_MS = 10000; // Maximum total wait time\r\nexport const DELAYED_EXTRACTION_CHECK_INTERVAL_MS = 300; // How often to check if hooks settled\r\n\r\n// Cache configuration\r\nexport const DELETION_CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\r\n\r\n// Authentication configuration\r\nexport const PROACTIVE_REFRESH_THRESHOLD_MS = 5 * 60 * 1000; // Proactively refresh JWT/access tokens 5 minutes before expiration\r\n\r\n// Content size limits\r\nexport const MAX_DIFF_SIZE_BYTES = 10 * 1024 * 1024; // 10MB\r\nexport const MAX_CONTENT_PREVIEW_LENGTH = 1000; // characters\r\nexport const MAX_SESSION_TITLE_LENGTH = 100; // characters\r\nexport const MIN_SESSION_TITLE_LENGTH = 3; // characters\r\n\r\n// Session quality filters\r\nexport const MIN_MESSAGES_PER_SESSION = 3; // Minimum messages required to upload a session\r\nexport const STALE_SESSION_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\r\n\r\n// API endpoints (configured from .env at build time)\r\n// Values are baked into the bundle during build\r\nexport const WEB_APP_URL = process.env.ZEST_WEB_APP_URL || \"http://localhost:3000\";\r\nexport const SUPABASE_URL = process.env.ZEST_SUPABASE_URL || \"\";\r\nexport const SUPABASE_ANON_KEY = process.env.ZEST_SUPABASE_ANON_KEY || \"\";\r\n\r\n// Claude project directories\r\nexport const CLAUDE_PROJECTS_DIR = join(homedir(), \".claude\", \"projects\");\r\n\r\n// Filter patterns for commands/messages to exclude from tracking\r\nexport const EXCLUDED_COMMAND_PATTERNS = [\r\n  // Claude Code built-in commands\r\n  /^\\/(add-dir|agents|bashes|bug|clear|compact|config|context|cost|doctor|exit|export|help|hooks|ide|init|install-github-app|login|logout|mcp|memory|model|output-style|permissions|plugin|pr-comments|privacy-settings|release-notes|resume|review|rewind|sandbox|security-review|stats|status|statusline|terminal-setup|todos|usage|vim)\\b/i,\r\n\r\n  // Zest plugin commands (like /zest:status, /zest-dev:status, etc.)\r\n  /^\\/zest[^:\\s]*:/i,\r\n\r\n  // Messages containing Zest command tags (e.g., <command-name>/zest-dev:status</command-name>)\r\n  /<command-name>\\/zest[^<]*<\\/command-name>/i,\r\n\r\n  // Messages containing Zest CLI script paths (e.g., \"node .../dist/commands/sync-cli.js\")\r\n  /node\\s+.*\\/dist\\/commands\\/.*-cli\\.js/i,\r\n];\r\n\r\nexport const ZEST_SESSION_NAMESPACE = \"1b671a64-40d5-491e-99b0-da01ff1f3341\";\r\n",
    "/**\r\n * Logging utilities\r\n *\r\n * Handles logging to console and file system\r\n */\r\n\r\nimport { appendFile, mkdir } from \"node:fs/promises\";\r\nimport { dirname } from \"node:path\";\r\nimport { LOG_FILE } from \"../config/constants.js\";\r\n\r\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\r\n\r\nclass Logger {\r\n  private minLevel: LogLevel = \"info\";\r\n  private readonly logFilePath: string;\r\n\r\n  private levels: Record<LogLevel, number> = {\r\n    debug: 0,\r\n    info: 1,\r\n    warn: 2,\r\n    error: 3,\r\n  };\r\n\r\n  constructor(logFilePath: string = LOG_FILE) {\r\n    this.logFilePath = logFilePath;\r\n  }\r\n\r\n  setLevel(level: LogLevel): void {\r\n    this.minLevel = level;\r\n  }\r\n\r\n  private async writeToFile(message: string): Promise<void> {\r\n    try {\r\n      await mkdir(dirname(this.logFilePath), { recursive: true });\r\n      const timestamp = new Date().toISOString();\r\n      await appendFile(this.logFilePath, `[${timestamp}] ${message}\\n`, \"utf-8\");\r\n    } catch (error) {\r\n      // Silently fail - don't crash if we can't write logs\r\n      console.error(\"Failed to write to log file:\", error);\r\n    }\r\n  }\r\n\r\n  private shouldLog(level: LogLevel): boolean {\r\n    return this.levels[level] >= this.levels[this.minLevel];\r\n  }\r\n\r\n  debug(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"debug\")) {\r\n      // Only write to file, don't clutter console\r\n      this.writeToFile(`DEBUG: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  info(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"info\")) {\r\n      // Only write to file, don't clutter console\r\n      this.writeToFile(`INFO: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  warn(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"warn\")) {\r\n      // Show warnings to user\r\n      console.warn(`[Zest:Warn] ${message}`, ...args);\r\n      this.writeToFile(`WARN: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  error(message: string, error?: unknown): void {\r\n    if (this.shouldLog(\"error\")) {\r\n      // Show errors to user\r\n      console.error(`[Zest:Error] ${message}`, error);\r\n      this.writeToFile(\r\n        `ERROR: ${message} ${error instanceof Error ? error.stack : JSON.stringify(error)}`,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport const logger = new Logger();\r\n"
  ],
  "mappings": "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",
  "debugId": "F7C9230CF6EC912D64756E2164756E21",
  "names": []
}