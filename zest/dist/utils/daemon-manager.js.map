{
  "version": 3,
  "sources": ["../src/utils/daemon-manager.ts", "../src/config/constants.ts", "../src/utils/logger.ts"],
  "sourcesContent": [
    "/**\n * Daemon lifecycle management\n *\n * Handles PID tracking, daemon startup, and process detection\n */\n\nimport { spawn } from \"node:child_process\";\nimport { readFile, unlink, writeFile } from \"node:fs/promises\";\nimport { dirname, join } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport { DAEMON_PID_FILE } from \"../config/constants.js\";\nimport { logger } from \"./logger.js\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n/**\n * Start the sync daemon as a detached background process\n */\nexport async function startDaemon(): Promise<boolean> {\n  try {\n    logger.info(\"Starting sync daemon...\");\n\n    // Find the daemon script path\n    const daemonScript = join(__dirname, \"..\", \"sync-daemon.js\");\n\n    // Spawn daemon as detached background process\n    const daemon = spawn(process.execPath, [daemonScript], {\n      detached: true, // Run independently\n      stdio: \"ignore\", // Don't capture output\n      windowsHide: true, // Hide console window on Windows\n    });\n\n    // Unref so parent can exit without waiting for daemon\n    daemon.unref();\n\n    logger.info(`✓ Daemon started (PID: ${daemon.pid})`);\n\n    // Daemon writes its own PID file when it starts\n    // Wait a moment to ensure it's written\n    await new Promise((resolve) => setTimeout(resolve, 100));\n\n    return true;\n  } catch (error) {\n    logger.error(\"Failed to start daemon:\", error);\n    return false;\n  }\n}\n\n/**\n * Restart daemon - kills existing daemon and starts a new one\n * Useful for picking up plugin updates\n */\nexport async function restartDaemon(): Promise<boolean> {\n  try {\n    logger.info(\"Restarting daemon...\");\n\n    // Kill existing daemon if running\n    const pid = await getDaemonPid();\n    if (pid) {\n      logger.info(`Stopping existing daemon (PID: ${pid})`);\n      try {\n        process.kill(pid, \"SIGTERM\");\n        // Wait a moment for graceful shutdown\n        await new Promise((resolve) => setTimeout(resolve, 500));\n      } catch (error) {\n        logger.warn(`Failed to stop daemon PID ${pid}:`, error);\n      }\n      await cleanupPidFile();\n    }\n\n    // Start new daemon\n    const started = await startDaemon();\n    if (started) {\n      logger.info(\"✓ Daemon restarted successfully\");\n    }\n    return started;\n  } catch (error) {\n    logger.error(\"Failed to restart daemon:\", error);\n    return false;\n  }\n}\n\n/**\n * Clean up stale PID file\n */\nasync function cleanupPidFile(): Promise<void> {\n  try {\n    await unlink(DAEMON_PID_FILE);\n  } catch {\n    // Ignore errors - file might not exist\n  }\n}\n\n/**\n * Write PID to daemon.pid file\n * Called by the daemon itself when it starts\n */\nexport async function writePidFile(pid: number): Promise<void> {\n  try {\n    await writeFile(DAEMON_PID_FILE, pid.toString(), \"utf-8\");\n    logger.debug(`Wrote PID ${pid} to daemon.pid`);\n  } catch (error) {\n    logger.error(\"Failed to write PID file:\", error);\n  }\n}\n\n/**\n * Get daemon PID (if running)\n */\nexport async function getDaemonPid(): Promise<number | null> {\n  try {\n    const pidData = await readFile(DAEMON_PID_FILE, \"utf-8\");\n    const pid = Number.parseInt(pidData.trim(), 10);\n\n    if (Number.isNaN(pid)) {\n      return null;\n    }\n\n    // Verify process exists\n    try {\n      process.kill(pid, 0);\n      return pid;\n    } catch {\n      return null;\n    }\n  } catch {\n    return null;\n  }\n}\n",
    "/**\n * Application constants and configuration values\n */\n\nimport { homedir } from \"node:os\";\nimport { join } from \"node:path\";\n\n// Base directories\nexport const CLAUDE_ZEST_DIR = join(homedir(), \".claude-zest\");\nexport const QUEUE_DIR = join(CLAUDE_ZEST_DIR, \"queue\");\nexport const LOGS_DIR = join(CLAUDE_ZEST_DIR, \"logs\");\nexport const STATE_DIR = join(CLAUDE_ZEST_DIR, \"state\");\n\n// File paths\nexport const SESSION_FILE = join(CLAUDE_ZEST_DIR, \"session.json\"); // Auth session + workspace info\nexport const SETTINGS_FILE = join(CLAUDE_ZEST_DIR, \"settings.json\"); // User preferences\nexport const LOG_FILE = join(LOGS_DIR, \"plugin.log\");\nexport const SYNC_LOG_FILE = join(LOGS_DIR, \"sync.log\");\nexport const DAEMON_PID_FILE = join(CLAUDE_ZEST_DIR, \"daemon.pid\");\n\n// Queue files\nexport const EVENTS_QUEUE_FILE = join(QUEUE_DIR, \"events.jsonl\");\nexport const SESSIONS_QUEUE_FILE = join(QUEUE_DIR, \"chat-sessions.jsonl\");\nexport const MESSAGES_QUEUE_FILE = join(QUEUE_DIR, \"chat-messages.jsonl\");\n\n// Platform and source identifiers\nexport const PLATFORM = \"terminal\";\nexport const SOURCE = \"claude-code\";\nexport const CLIENT_ID = \"claude-cli\";\n\n// Sync configuration\nexport const SYNC_INTERVAL_MS = 60000; // 60 seconds\nexport const MAX_RETRY_ATTEMPTS = 3;\nexport const RETRY_BACKOFF_MS = 5000;\n\n// Authentication configuration\nexport const PROACTIVE_REFRESH_THRESHOLD_MS = 5 * 60 * 1000; // Refresh tokens 5 minutes before expiration\n\n// Content size limits\nexport const MAX_DIFF_SIZE_BYTES = 10 * 1024 * 1024; // 10MB\nexport const MAX_CONTENT_PREVIEW_LENGTH = 1000; // characters\nexport const MAX_SESSION_TITLE_LENGTH = 100; // characters\nexport const MIN_SESSION_TITLE_LENGTH = 3; // characters\n\n// Session quality filters\nexport const MIN_MESSAGES_PER_SESSION = 3; // Minimum messages required to upload a session\nexport const STALE_SESSION_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\n\n// API endpoints (configured from .env at build time)\n// Values are baked into the bundle during build\nexport const WEB_APP_URL = process.env.ZEST_WEB_APP_URL || \"http://localhost:3000\";\nexport const SUPABASE_URL = process.env.ZEST_SUPABASE_URL || \"\";\nexport const SUPABASE_ANON_KEY = process.env.ZEST_SUPABASE_ANON_KEY || \"\";\n\n// Claude project directories\nexport const CLAUDE_PROJECTS_DIR = join(homedir(), \".claude\", \"projects\");\n",
    "/**\n * Logging utilities\n *\n * Handles logging to console and file system\n */\n\nimport { appendFile, mkdir } from \"node:fs/promises\";\nimport { dirname } from \"node:path\";\nimport { LOG_FILE } from \"../config/constants.js\";\n\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nclass Logger {\n  private minLevel: LogLevel = \"info\";\n\n  private levels: Record<LogLevel, number> = {\n    debug: 0,\n    info: 1,\n    warn: 2,\n    error: 3,\n  };\n\n  setLevel(level: LogLevel): void {\n    this.minLevel = level;\n  }\n\n  private async writeToFile(message: string): Promise<void> {\n    try {\n      await mkdir(dirname(LOG_FILE), { recursive: true });\n      const timestamp = new Date().toISOString();\n      await appendFile(LOG_FILE, `[${timestamp}] ${message}\\n`, \"utf-8\");\n    } catch (error) {\n      // Silently fail - don't crash if we can't write logs\n      console.error(\"Failed to write to log file:\", error);\n    }\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    return this.levels[level] >= this.levels[this.minLevel];\n  }\n\n  debug(message: string, ...args: unknown[]): void {\n    if (this.shouldLog(\"debug\")) {\n      // Only write to file, don't clutter console\n      this.writeToFile(`DEBUG: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\n    }\n  }\n\n  info(message: string, ...args: unknown[]): void {\n    if (this.shouldLog(\"info\")) {\n      // Only write to file, don't clutter console\n      this.writeToFile(`INFO: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\n    }\n  }\n\n  warn(message: string, ...args: unknown[]): void {\n    if (this.shouldLog(\"warn\")) {\n      // Show warnings to user\n      console.warn(`[Zest:Warn] ${message}`, ...args);\n      this.writeToFile(`WARN: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\n    }\n  }\n\n  error(message: string, error?: unknown): void {\n    if (this.shouldLog(\"error\")) {\n      // Show errors to user\n      console.error(`[Zest:Error] ${message}`, error);\n      this.writeToFile(\n        `ERROR: ${message} ${error instanceof Error ? error.stack : JSON.stringify(error)}`,\n      );\n    }\n  }\n}\n\nexport const logger = new Logger();\n"
  ],
  "mappings": "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",
  "debugId": "B554EEEFE1EC7BEA64756E2164756E21",
  "names": []
}