{
  "version": 3,
  "sources": ["../src/utils/queue-manager.ts", "../src/config/constants.ts", "../src/utils/file-lock.ts", "../src/utils/daemon-manager.ts", "../src/utils/logger.ts"],
  "sourcesContent": [
    "/**\r\n * Local queue management for data persistence\r\n *\r\n * Manages JSONL queue files for events, sessions, and messages\r\n * Uses file-based locking to prevent corruption from concurrent access\r\n */\r\n\r\nimport { appendFile, mkdir, readFile, stat, unlink, writeFile } from \"node:fs/promises\";\r\nimport { dirname } from \"node:path\";\r\nimport {\r\n  EVENTS_QUEUE_FILE,\r\n  MESSAGES_QUEUE_FILE,\r\n  QUEUE_DIR,\r\n  SESSIONS_QUEUE_FILE,\r\n} from \"../config/constants.js\";\r\nimport type {\r\n  ClaudeExtractedEvent,\r\n  ClaudeExtractedMessage,\r\n  ClaudeExtractedSession,\r\n} from \"../types/index.js\";\r\nimport { withFileLock } from \"./file-lock.js\";\r\nimport { logger } from \"./logger.js\";\r\n\r\n/**\r\n * Ensure directory exists, creating it if necessary\r\n */\r\nasync function ensureDirectory(dirPath: string): Promise<void> {\r\n  try {\r\n    await stat(dirPath);\r\n  } catch {\r\n    await mkdir(dirPath, { recursive: true, mode: 0o700 });\r\n    logger.debug(`Created directory: ${dirPath}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Read all entries from a JSONL file\r\n */\r\nasync function readJsonl<T>(filePath: string): Promise<T[]> {\r\n  try {\r\n    const content = await readFile(filePath, \"utf8\");\r\n    const lines = content.trim().split(\"\\n\").filter(Boolean);\r\n\r\n    const results: T[] = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n      try {\r\n        results.push(JSON.parse(lines[i]));\r\n      } catch (error) {\r\n        logger.warn(`Failed to parse line ${i + 1} in ${filePath}:`, error);\r\n        // Continue processing other lines\r\n      }\r\n    }\r\n\r\n    return results;\r\n  } catch (error) {\r\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\r\n      // File doesn't exist yet, return empty array\r\n      return [];\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Count lines in a JSONL file\r\n */\r\nasync function countLines(filePath: string): Promise<number> {\r\n  try {\r\n    const content = await readFile(filePath, \"utf8\");\r\n    const lines = content.trim().split(\"\\n\").filter(Boolean);\r\n    return lines.length;\r\n  } catch (error) {\r\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\r\n      return 0;\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Delete a file (clear queue)\r\n */\r\nasync function deleteFile(filePath: string): Promise<void> {\r\n  try {\r\n    await unlink(filePath);\r\n  } catch (error) {\r\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\r\n      // File doesn't exist, nothing to delete\r\n      return;\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Public API\r\n// ============================================================================\r\n\r\n/**\r\n * Enqueue a code digest event extracted from Claude Code CLI\r\n * Skips events that are already in the queue (deduplication)\r\n */\r\nexport async function enqueueEvent(event: ClaudeExtractedEvent): Promise<void> {\r\n  try {\r\n    // Use lock to ensure atomicity of read-check-write\r\n    await withFileLock(EVENTS_QUEUE_FILE, async () => {\r\n      // Check if event already exists (inside lock to prevent race conditions)\r\n      const existingEvents = await readJsonl<ClaudeExtractedEvent>(EVENTS_QUEUE_FILE);\r\n      const isDuplicate = existingEvents.some((evt) => evt.id === event.id);\r\n\r\n      if (isDuplicate) {\r\n        logger.debug(\"Skipping duplicate event\", {\r\n          eventId: event.id,\r\n          documentUri: event.document_uri,\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Ensure directory exists\r\n      await ensureDirectory(dirname(EVENTS_QUEUE_FILE));\r\n\r\n      // Append JSON line\r\n      const line = JSON.stringify(event) + \"\\n\";\r\n      await appendFile(EVENTS_QUEUE_FILE, line, \"utf8\");\r\n\r\n      logger.debug(\"Enqueued event\", { eventId: event.id, documentUri: event.document_uri });\r\n    });\r\n  } catch (error) {\r\n    logger.error(\"Failed to enqueue event:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Enqueue a chat session extracted from Claude Code CLI\r\n * Skips sessions that are already in the queue (deduplication)\r\n */\r\nexport async function enqueueChatSession(session: ClaudeExtractedSession): Promise<void> {\r\n  try {\r\n    // Use lock to ensure atomicity of read-check-write\r\n    await withFileLock(SESSIONS_QUEUE_FILE, async () => {\r\n      // Check if session already exists (inside lock to prevent race conditions)\r\n      const existingSessions = await readJsonl<ClaudeExtractedSession>(SESSIONS_QUEUE_FILE);\r\n      const isDuplicate = existingSessions.some((sess) => sess.id === session.id);\r\n\r\n      if (isDuplicate) {\r\n        logger.debug(\"Skipping duplicate session\", { sessionId: session.id });\r\n        return;\r\n      }\r\n\r\n      // Ensure directory exists\r\n      await ensureDirectory(dirname(SESSIONS_QUEUE_FILE));\r\n\r\n      // Append JSON line\r\n      const line = JSON.stringify(session) + \"\\n\";\r\n      await appendFile(SESSIONS_QUEUE_FILE, line, \"utf8\");\r\n\r\n      logger.debug(\"Enqueued session\", { sessionId: session.id });\r\n    });\r\n  } catch (error) {\r\n    logger.error(\"Failed to enqueue session:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Enqueue a chat message extracted from Claude Code CLI\r\n * Skips messages that are already in the queue (deduplication)\r\n */\r\nexport async function enqueueChatMessage(message: ClaudeExtractedMessage): Promise<void> {\r\n  try {\r\n    // Use lock to ensure atomicity of read-check-write\r\n    await withFileLock(MESSAGES_QUEUE_FILE, async () => {\r\n      // Check if message already exists (inside lock to prevent race conditions)\r\n      const existingMessages = await readJsonl<ClaudeExtractedMessage>(MESSAGES_QUEUE_FILE);\r\n      const isDuplicate = existingMessages.some((msg) => msg.id === message.id);\r\n\r\n      if (isDuplicate) {\r\n        logger.debug(\"Skipping duplicate message\", {\r\n          messageId: message.id,\r\n          sessionId: message.session_id,\r\n          messageIndex: message.message_index,\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Ensure directory exists\r\n      await ensureDirectory(dirname(MESSAGES_QUEUE_FILE));\r\n\r\n      // Append JSON line\r\n      const line = JSON.stringify(message) + \"\\n\";\r\n      await appendFile(MESSAGES_QUEUE_FILE, line, \"utf8\");\r\n\r\n      logger.debug(\"Enqueued message\", {\r\n        sessionId: message.session_id,\r\n        messageIndex: message.message_index,\r\n      });\r\n    });\r\n  } catch (error) {\r\n    logger.error(\"Failed to enqueue message:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Read all entries from a queue file\r\n */\r\nexport async function readQueue<T>(queueFile: string): Promise<T[]> {\r\n  try {\r\n    return await readJsonl<T>(queueFile);\r\n  } catch (error) {\r\n    logger.error(`Failed to read queue file ${queueFile}:`, error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Write entries to a queue file (overwrites existing content)\r\n */\r\nexport async function writeQueue<T>(queueFile: string, items: T[]): Promise<void> {\r\n  try {\r\n    await withFileLock(queueFile, async () => {\r\n      await ensureDirectory(dirname(queueFile));\r\n\r\n      // Write all items as JSONL\r\n      const content =\r\n        items.map((item) => JSON.stringify(item)).join(\"\\n\") + (items.length > 0 ? \"\\n\" : \"\");\r\n      await writeFile(queueFile, content, \"utf8\");\r\n\r\n      logger.debug(`Wrote ${items.length} items to queue file: ${queueFile}`);\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Failed to write queue file ${queueFile}:`, error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Atomically update queue files with a transform function\r\n * Ensures no race condition between read and write\r\n *\r\n * The entire read-modify-write cycle happens inside a lock\r\n */\r\nexport async function atomicUpdateQueue<T>(\r\n  queueFile: string,\r\n  transform: (currentItems: T[]) => T[],\r\n): Promise<void> {\r\n  try {\r\n    await withFileLock(queueFile, async () => {\r\n      // Read current state (inside lock)\r\n      const currentItems = await readJsonl<T>(queueFile);\r\n\r\n      // Apply transformation\r\n      const newItems = transform(currentItems);\r\n\r\n      // Write back (still inside lock)\r\n      await ensureDirectory(dirname(queueFile));\r\n      const content =\r\n        newItems.map((item) => JSON.stringify(item)).join(\"\\n\") + (newItems.length > 0 ? \"\\n\" : \"\");\r\n      await writeFile(queueFile, content, \"utf8\");\r\n\r\n      logger.debug(\r\n        `Atomically updated queue file: ${queueFile} (${currentItems.length} â†’ ${newItems.length} items)`,\r\n      );\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Failed to atomically update queue file ${queueFile}:`, error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Clear a queue file (delete it)\r\n */\r\nexport async function clearQueue(queueFile: string): Promise<void> {\r\n  try {\r\n    await withFileLock(queueFile, async () => {\r\n      await deleteFile(queueFile);\r\n      logger.debug(`Cleared queue file: ${queueFile}`);\r\n    });\r\n  } catch (error) {\r\n    logger.error(`Failed to clear queue file ${queueFile}:`, error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Get statistics about queued items\r\n */\r\nexport async function getQueueStats(): Promise<{\r\n  events: number;\r\n  sessions: number;\r\n  messages: number;\r\n}> {\r\n  try {\r\n    const [events, sessions, messages] = await Promise.all([\r\n      countLines(EVENTS_QUEUE_FILE),\r\n      countLines(SESSIONS_QUEUE_FILE),\r\n      countLines(MESSAGES_QUEUE_FILE),\r\n    ]);\r\n\r\n    return { events, sessions, messages };\r\n  } catch (error) {\r\n    logger.error(\"Failed to get queue stats:\", error);\r\n    return { events: 0, sessions: 0, messages: 0 };\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure queue directory exists (call on initialization)\r\n */\r\nexport async function initializeQueue(): Promise<void> {\r\n  try {\r\n    await ensureDirectory(QUEUE_DIR);\r\n    logger.debug(\"Queue directory initialized\");\r\n  } catch (error) {\r\n    logger.error(\"Failed to initialize queue directory:\", error);\r\n    throw error;\r\n  }\r\n}\r\n",
    "/**\r\n * Application constants and configuration values\r\n */\r\n\r\nimport { homedir } from \"node:os\";\r\nimport { join } from \"node:path\";\r\n\r\n// Base directories\r\nexport const CLAUDE_ZEST_DIR = join(\r\n  homedir(),\r\n  `.claude-zest${process.env.NODE_ENV === \"development\" ? \"-dev\" : \"\"}`,\r\n);\r\nexport const QUEUE_DIR = join(CLAUDE_ZEST_DIR, \"queue\");\r\nexport const LOGS_DIR = join(CLAUDE_ZEST_DIR, \"logs\");\r\nexport const STATE_DIR = join(CLAUDE_ZEST_DIR, \"state\");\r\nexport const DELETION_CACHE_DIR = join(CLAUDE_ZEST_DIR, \"cache\", \"deletions\");\r\n\r\n// File paths\r\nexport const SESSION_FILE = join(CLAUDE_ZEST_DIR, \"session.json\"); // Auth session + workspace info\r\nexport const SETTINGS_FILE = join(CLAUDE_ZEST_DIR, \"settings.json\"); // User preferences\r\nexport const LOG_FILE = join(LOGS_DIR, \"plugin.log\");\r\nexport const SYNC_LOG_FILE = join(LOGS_DIR, \"sync.log\");\r\nexport const DAEMON_PID_FILE = join(CLAUDE_ZEST_DIR, \"daemon.pid\");\r\n\r\n// Queue files\r\nexport const EVENTS_QUEUE_FILE = join(QUEUE_DIR, \"events.jsonl\");\r\nexport const SESSIONS_QUEUE_FILE = join(QUEUE_DIR, \"chat-sessions.jsonl\");\r\nexport const MESSAGES_QUEUE_FILE = join(QUEUE_DIR, \"chat-messages.jsonl\");\r\n\r\n// Platform and source identifiers\r\nexport const PLATFORM = \"terminal\";\r\nexport const SOURCE = \"claude-code\";\r\nexport const CLIENT_ID = \"claude-cli\";\r\n\r\n// Sync configuration\r\nexport const SYNC_INTERVAL_MS = 60000; // 60 seconds\r\nexport const MAX_RETRY_ATTEMPTS = 3;\r\nexport const RETRY_BACKOFF_MS = 5000;\r\n\r\n// File locking configuration\r\nexport const LOCK_RETRY_MS = 50; // Retry interval when lock is held by another process\r\nexport const LOCK_MAX_RETRIES = 300; // Max retries (10 seconds total)\r\n\r\n// Debounce configuration (prevents duplicate hook executions)\r\nexport const DEBOUNCE_DIR = join(CLAUDE_ZEST_DIR, \"debounce\");\r\nexport const DEBOUNCE_WINDOW_MS = 500; // First-wins debounce window\r\nexport const DEBOUNCE_TRAILING_MS = 300; // Trailing debounce: wait after last hook before processing\r\n\r\n// Delayed extraction configuration (for PostToolUse trailing debounce)\r\nexport const DELAYED_EXTRACTION_INITIAL_DELAY_MS = 500; // Initial wait before checking if hooks settled\r\nexport const DELAYED_EXTRACTION_MAX_WAIT_MS = 10000; // Maximum total wait time\r\nexport const DELAYED_EXTRACTION_CHECK_INTERVAL_MS = 300; // How often to check if hooks settled\r\n\r\n// Cache configuration\r\nexport const DELETION_CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\r\n\r\n// Authentication configuration\r\nexport const PROACTIVE_REFRESH_THRESHOLD_MS = 5 * 60 * 1000; // Proactively refresh JWT/access tokens 5 minutes before expiration\r\n\r\n// Content size limits\r\nexport const MAX_DIFF_SIZE_BYTES = 10 * 1024 * 1024; // 10MB\r\nexport const MAX_CONTENT_PREVIEW_LENGTH = 1000; // characters\r\nexport const MAX_SESSION_TITLE_LENGTH = 100; // characters\r\nexport const MIN_SESSION_TITLE_LENGTH = 3; // characters\r\n\r\n// Session quality filters\r\nexport const MIN_MESSAGES_PER_SESSION = 3; // Minimum messages required to upload a session\r\nexport const STALE_SESSION_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\r\n\r\n// API endpoints (configured from .env at build time)\r\n// Values are baked into the bundle during build\r\nexport const WEB_APP_URL = process.env.ZEST_WEB_APP_URL || \"http://localhost:3000\";\r\nexport const SUPABASE_URL = process.env.ZEST_SUPABASE_URL || \"\";\r\nexport const SUPABASE_ANON_KEY = process.env.ZEST_SUPABASE_ANON_KEY || \"\";\r\n\r\n// Claude project directories\r\nexport const CLAUDE_PROJECTS_DIR = join(homedir(), \".claude\", \"projects\");\r\n\r\n// Filter patterns for commands/messages to exclude from tracking\r\nexport const EXCLUDED_COMMAND_PATTERNS = [\r\n  // Claude Code built-in commands\r\n  /^\\/(add-dir|agents|bashes|bug|clear|compact|config|context|cost|doctor|exit|export|help|hooks|ide|init|install-github-app|login|logout|mcp|memory|model|output-style|permissions|plugin|pr-comments|privacy-settings|release-notes|resume|review|rewind|sandbox|security-review|stats|status|statusline|terminal-setup|todos|usage|vim)\\b/i,\r\n\r\n  // Zest plugin commands (like /zest:status, /zest-dev:status, etc.)\r\n  /^\\/zest[^:\\s]*:/i,\r\n\r\n  // Messages containing Zest command tags (e.g., <command-name>/zest-dev:status</command-name>)\r\n  /<command-name>\\/zest[^<]*<\\/command-name>/i,\r\n\r\n  // Messages containing Zest CLI script paths (e.g., \"node .../dist/commands/sync-cli.js\")\r\n  /node\\s+.*\\/dist\\/commands\\/.*-cli\\.js/i,\r\n];\r\n\r\nexport const ZEST_SESSION_NAMESPACE = \"1b671a64-40d5-491e-99b0-da01ff1f3341\";\r\n",
    "/**\r\n * Cross-process file locking utility\r\n *\r\n * Provides file-based locking to prevent corruption from concurrent access\r\n * across different processes (plugin hooks vs daemon)\r\n *\r\n * Uses PID-based stale lock detection - a lock is only considered stale\r\n * if the owning process is dead, allowing long-running operations.\r\n */\r\n\r\nimport { unlinkSync } from \"node:fs\";\r\nimport { readdir, readFile, unlink, writeFile } from \"node:fs/promises\";\r\nimport { LOCK_MAX_RETRIES, LOCK_RETRY_MS, QUEUE_DIR } from \"../config/constants.js\";\r\nimport { isProcessRunning } from \"./daemon-manager.js\";\r\nimport { logger } from \"./logger.js\";\r\n\r\n/**\r\n * Lock file metadata - stored in .lock files\r\n */\r\ninterface LockInfo {\r\n  pid: number;\r\n  timestamp: number; // For debugging/logging only - PID is authoritative\r\n}\r\n\r\n// Track active lock files for cleanup on process exit\r\nconst activeLockFiles = new Set<string>();\r\n\r\n/**\r\n * Check if a lock file represents a stale lock\r\n * A lock is stale ONLY if the owning process is dead\r\n * This ensures long-running operations (like uploads) don't have their locks stolen\r\n */\r\nfunction isLockStale(lockInfo: LockInfo): boolean {\r\n  return !isProcessRunning(lockInfo.pid);\r\n}\r\n\r\n/**\r\n * Acquire a file-based lock (cross-process safe)\r\n * Uses atomic file creation with 'wx' flag to prevent race conditions\r\n *\r\n * @returns true if lock was acquired, false if held by another active process\r\n */\r\nasync function acquireFileLock(filePath: string): Promise<boolean> {\r\n  const lockFile = `${filePath}.lock`;\r\n  const lockInfo: LockInfo = {\r\n    pid: process.pid,\r\n    timestamp: Date.now(),\r\n  };\r\n\r\n  try {\r\n    // 'wx' flag = exclusive create - fails atomically if file already exists\r\n    await writeFile(lockFile, JSON.stringify(lockInfo), { flag: \"wx\" });\r\n    activeLockFiles.add(lockFile);\r\n    return true;\r\n  } catch (error) {\r\n    if ((error as NodeJS.ErrnoException).code !== \"EEXIST\") {\r\n      throw error; // Unexpected error - rethrow\r\n    }\r\n\r\n    // Lock file exists - check if it's stale (owning process is dead)\r\n    try {\r\n      const content = await readFile(lockFile, \"utf8\");\r\n      const existingLock: LockInfo = JSON.parse(content);\r\n\r\n      if (isLockStale(existingLock)) {\r\n        // Remove stale lock and retry\r\n        logger.debug(`Removing stale lock for ${filePath} (PID ${existingLock.pid} is dead)`);\r\n        await unlink(lockFile).catch(() => {});\r\n        return acquireFileLock(filePath); // Recursive retry\r\n      }\r\n    } catch {\r\n      // Couldn't read/parse lock file - it may be corrupted or being written\r\n      // Remove it and retry\r\n      logger.debug(`Lock file for ${filePath} is corrupted or unreadable, removing`);\r\n      await unlink(lockFile).catch(() => {});\r\n      return acquireFileLock(filePath);\r\n    }\r\n\r\n    return false; // Lock is held by an active process\r\n  }\r\n}\r\n\r\n/**\r\n * Release a file-based lock\r\n */\r\nasync function releaseFileLock(filePath: string): Promise<void> {\r\n  const lockFile = `${filePath}.lock`;\r\n  activeLockFiles.delete(lockFile);\r\n  await unlink(lockFile).catch(() => {}); // Ignore errors - file might already be gone\r\n}\r\n\r\n/**\r\n * Cleanup handler for graceful shutdown\r\n * Removes any lock files this process holds\r\n */\r\nfunction cleanupLockFiles(): void {\r\n  for (const lockFile of activeLockFiles) {\r\n    try {\r\n      unlinkSync(lockFile); // Must be sync in exit handler\r\n    } catch {\r\n      // Ignore errors during cleanup\r\n    }\r\n  }\r\n  activeLockFiles.clear();\r\n}\r\n\r\n/**\r\n * Clean up any stale lock files in the queue directory\r\n * Called during daemon restart to remove orphaned locks from crashed processes\r\n */\r\nexport async function cleanupStaleLocks(): Promise<void> {\r\n  try {\r\n    const files = await readdir(QUEUE_DIR).catch(() => [] as string[]);\r\n    const lockFiles = files.filter((f) => f.endsWith(\".lock\"));\r\n\r\n    for (const lockFileName of lockFiles) {\r\n      const lockFile = `${QUEUE_DIR}/${lockFileName}`;\r\n      try {\r\n        const content = await readFile(lockFile, \"utf8\");\r\n        const lockInfo: LockInfo = JSON.parse(content);\r\n\r\n        if (!isProcessRunning(lockInfo.pid)) {\r\n          await unlink(lockFile);\r\n          logger.info(`Cleaned up stale lock file: ${lockFileName} (PID ${lockInfo.pid} is dead)`);\r\n        }\r\n      } catch {\r\n        // Corrupted lock file - remove it\r\n        await unlink(lockFile).catch(() => {});\r\n        logger.info(`Removed corrupted lock file: ${lockFileName}`);\r\n      }\r\n    }\r\n  } catch (error) {\r\n    logger.debug(\"Failed to clean up stale locks:\", error);\r\n  }\r\n}\r\n\r\n// Set up cleanup handlers for graceful shutdown\r\nlet cleanupRegistered = false;\r\n\r\n/**\r\n * Register process exit handlers to clean up lock files\r\n * Safe to call multiple times - only registers once\r\n */\r\nexport function setupLockCleanup(): void {\r\n  if (cleanupRegistered) return;\r\n  cleanupRegistered = true;\r\n\r\n  process.on(\"exit\", cleanupLockFiles);\r\n  process.on(\"SIGINT\", () => {\r\n    cleanupLockFiles();\r\n    process.exit(0);\r\n  });\r\n  process.on(\"SIGTERM\", () => {\r\n    cleanupLockFiles();\r\n    process.exit(0);\r\n  });\r\n\r\n  logger.debug(\"Lock cleanup handlers registered\");\r\n}\r\n\r\n/**\r\n * Execute a function with exclusive file-based lock\r\n * Provides cross-process protection for file operations\r\n *\r\n * @param filePath - Path to the file to lock (creates filePath.lock)\r\n * @param fn - Function to execute while holding the lock\r\n * @returns The result of the function\r\n * @throws Error if lock cannot be acquired after max retries\r\n */\r\nexport async function withFileLock<T>(filePath: string, fn: () => Promise<T>): Promise<T> {\r\n  // Acquire file-based lock with retry\r\n  let retries = 0;\r\n  while (!(await acquireFileLock(filePath))) {\r\n    if (++retries >= LOCK_MAX_RETRIES) {\r\n      throw new Error(`Failed to acquire lock for ${filePath} after ${retries} retries`);\r\n    }\r\n    await new Promise((resolve) => setTimeout(resolve, LOCK_RETRY_MS));\r\n  }\r\n\r\n  try {\r\n    return await fn();\r\n  } finally {\r\n    await releaseFileLock(filePath);\r\n  }\r\n}\r\n",
    "/**\r\n * Daemon lifecycle management\r\n *\r\n * Handles PID tracking, daemon startup, and process detection\r\n */\r\n\r\nimport { exec, spawn } from \"node:child_process\";\r\nimport { readFile, stat, unlink, writeFile } from \"node:fs/promises\";\r\nimport { dirname, join } from \"node:path\";\r\nimport { fileURLToPath } from \"node:url\";\r\nimport { promisify } from \"node:util\";\r\nimport { CLAUDE_ZEST_DIR, DAEMON_PID_FILE } from \"../config/constants.js\";\r\nimport { cleanupStaleLocks, withFileLock } from \"./file-lock.js\";\r\nimport { logger } from \"./logger.js\";\r\n\r\n// Lock file to prevent concurrent daemon restarts\r\nconst DAEMON_RESTART_LOCK = join(CLAUDE_ZEST_DIR, \"daemon-restart.lock\");\r\n\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = dirname(__filename);\r\n\r\n/**\r\n * Check if a process is running (cross-platform)\r\n * Uses signal 0 which checks existence without actually sending a signal\r\n */\r\nexport function isProcessRunning(pid: number): boolean {\r\n  try {\r\n    process.kill(pid, 0);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Start the sync daemon as a detached background process\r\n */\r\nexport async function startDaemon(): Promise<boolean> {\r\n  try {\r\n    // Find the daemon script path\r\n    const daemonScript = join(__dirname, \"..\", \"sync-daemon.js\");\r\n\r\n    // Spawn daemon as detached background process\r\n    const daemon = spawn(process.execPath, [daemonScript], {\r\n      detached: true, // Run independently\r\n      stdio: \"ignore\", // Don't capture output\r\n      windowsHide: true, // Hide console window on Windows\r\n    });\r\n\r\n    // Unref so parent can exit without waiting for daemon\r\n    daemon.unref();\r\n\r\n    // Daemon writes its own PID file when it starts\r\n    // Wait a moment to ensure it's written\r\n    await new Promise((resolve) => setTimeout(resolve, 100));\r\n\r\n    return true;\r\n  } catch (error) {\r\n    logger.error(\"Failed to start daemon:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Kill all running sync-daemon processes\r\n * This ensures we don't accumulate zombie daemons\r\n */\r\nasync function killAllDaemons(): Promise<void> {\r\n  try {\r\n    // First try to kill the daemon from PID file\r\n    const pid = await getDaemonPid();\r\n    if (pid) {\r\n      try {\r\n        process.kill(pid, \"SIGTERM\");\r\n      } catch {\r\n        // Process might not exist\r\n      }\r\n    }\r\n\r\n    // Also try to kill any other sync-daemon processes using pkill\r\n    // This catches zombies that weren't tracked in PID file\r\n    const execAsync = promisify(exec);\r\n\r\n    try {\r\n      // Kill all sync-daemon.js processes (excluding our own process)\r\n      await execAsync(`pkill -f 'sync-daemon.js' 2>/dev/null || true`);\r\n    } catch {\r\n      // pkill might not find any processes, which is fine\r\n    }\r\n\r\n    // Wait for processes to terminate\r\n    await new Promise((resolve) => setTimeout(resolve, 500));\r\n\r\n    // Clean up PID file\r\n    await cleanupPidFile();\r\n  } catch (error) {\r\n    logger.warn(\"Error during daemon cleanup:\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * Restart daemon - kills ALL existing daemons and starts a fresh one\r\n * Uses file locking to prevent multiple hooks from starting multiple daemons\r\n */\r\nexport async function restartDaemon(): Promise<boolean> {\r\n  try {\r\n    // Use file lock to ensure only ONE process can restart the daemon at a time\r\n    return await withFileLock(DAEMON_RESTART_LOCK, async () => {\r\n      // Check if a daemon was JUST started (within last 2 seconds)\r\n      // This prevents the second hook from killing the daemon the first hook just started\r\n      const existingPid = await getDaemonPid();\r\n      if (existingPid) {\r\n        try {\r\n          const pidFileStat = await stat(DAEMON_PID_FILE);\r\n          const ageMs = Date.now() - pidFileStat.mtimeMs;\r\n\r\n          if (ageMs < 2000) {\r\n            // PID file is fresh - daemon was just started by another hook\r\n            return true;\r\n          }\r\n        } catch {\r\n          // Ignore errors checking PID file age\r\n        }\r\n      }\r\n\r\n      // Kill ALL existing daemon processes (not just the one in PID file)\r\n      await killAllDaemons();\r\n\r\n      // Clean up any stale lock files from crashed processes\r\n      await cleanupStaleLocks();\r\n\r\n      // Start new daemon\r\n      return await startDaemon();\r\n    });\r\n  } catch (error) {\r\n    logger.error(\"Failed to restart daemon:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Clean up stale PID file\r\n */\r\nasync function cleanupPidFile(): Promise<void> {\r\n  try {\r\n    await unlink(DAEMON_PID_FILE);\r\n  } catch {\r\n    // Ignore errors - file might not exist\r\n  }\r\n}\r\n\r\n/**\r\n * Write PID to daemon.pid file\r\n * Called by the daemon itself when it starts\r\n */\r\nexport async function writePidFile(pid: number): Promise<void> {\r\n  try {\r\n    await writeFile(DAEMON_PID_FILE, pid.toString(), \"utf-8\");\r\n    logger.debug(`Wrote PID ${pid} to daemon.pid`);\r\n  } catch (error) {\r\n    logger.error(\"Failed to write PID file:\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * Get daemon PID (if running)\r\n */\r\nexport async function getDaemonPid(): Promise<number | null> {\r\n  try {\r\n    const pidData = await readFile(DAEMON_PID_FILE, \"utf-8\");\r\n    const pid = Number.parseInt(pidData.trim(), 10);\r\n\r\n    if (Number.isNaN(pid)) {\r\n      return null;\r\n    }\r\n\r\n    // Verify process exists\r\n    return isProcessRunning(pid) ? pid : null;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n",
    "/**\r\n * Logging utilities\r\n *\r\n * Handles logging to console and file system\r\n */\r\n\r\nimport { appendFile, mkdir } from \"node:fs/promises\";\r\nimport { dirname } from \"node:path\";\r\nimport { LOG_FILE } from \"../config/constants.js\";\r\n\r\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\r\n\r\nclass Logger {\r\n  private minLevel: LogLevel = \"info\";\r\n  private readonly logFilePath: string;\r\n\r\n  private levels: Record<LogLevel, number> = {\r\n    debug: 0,\r\n    info: 1,\r\n    warn: 2,\r\n    error: 3,\r\n  };\r\n\r\n  constructor(logFilePath: string = LOG_FILE) {\r\n    this.logFilePath = logFilePath;\r\n  }\r\n\r\n  setLevel(level: LogLevel): void {\r\n    this.minLevel = level;\r\n  }\r\n\r\n  private async writeToFile(message: string): Promise<void> {\r\n    try {\r\n      await mkdir(dirname(this.logFilePath), { recursive: true });\r\n      const timestamp = new Date().toISOString();\r\n      await appendFile(this.logFilePath, `[${timestamp}] ${message}\\n`, \"utf-8\");\r\n    } catch (error) {\r\n      // Silently fail - don't crash if we can't write logs\r\n      console.error(\"Failed to write to log file:\", error);\r\n    }\r\n  }\r\n\r\n  private shouldLog(level: LogLevel): boolean {\r\n    return this.levels[level] >= this.levels[this.minLevel];\r\n  }\r\n\r\n  debug(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"debug\")) {\r\n      // Only write to file, don't clutter console\r\n      this.writeToFile(`DEBUG: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  info(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"info\")) {\r\n      // Only write to file, don't clutter console\r\n      this.writeToFile(`INFO: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  warn(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"warn\")) {\r\n      // Show warnings to user\r\n      console.warn(`[Zest:Warn] ${message}`, ...args);\r\n      this.writeToFile(`WARN: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  error(message: string, error?: unknown): void {\r\n    if (this.shouldLog(\"error\")) {\r\n      // Show errors to user\r\n      console.error(`[Zest:Error] ${message}`, error);\r\n      this.writeToFile(\r\n        `ERROR: ${message} ${error instanceof Error ? error.stack : JSON.stringify(error)}`,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport const logger = new Logger();\r\n"
  ],
  "mappings": "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",
  "debugId": "6673FE43F5224BA064756E2164756E21",
  "names": []
}