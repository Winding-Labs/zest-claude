{
  "version": 3,
  "sources": ["../src/utils/session-startup.ts", "../src/config/constants.ts", "../src/utils/fs-utils.ts", "../src/utils/logger.ts", "../src/utils/log-rotation.ts", "../src/utils/plugin-version.ts", "../src/utils/status-cache-manager.ts", "../src/utils/file-lock.ts", "../src/utils/daemon-manager.ts"],
  "sourcesContent": [
    "/**\r\n * Session Startup Utilities\r\n *\r\n * Helper functions for session start operations:\r\n * - Statusline script deployment\r\n * - Plugin update checking and caching\r\n */\r\n\r\nimport { createHash } from \"node:crypto\";\r\nimport { copyFile, readFile, stat } from \"node:fs/promises\";\r\nimport { dirname, join } from \"node:path\";\r\nimport { fileURLToPath } from \"node:url\";\r\nimport { CLAUDE_ZEST_DIR, STATUSLINE_SCRIPT_PATH } from \"../config/constants.js\";\r\nimport { ensureDirectory } from \"./fs-utils.js\";\r\nimport { logger } from \"./logger.js\";\r\nimport { checkForUpdates } from \"./plugin-version.js\";\r\nimport { writeVersionCheck } from \"./status-cache-manager.js\";\r\n\r\n/**\r\n * Calculate SHA-256 hash of a file\r\n * @param filePath - Path to file to hash\r\n * @returns Hex string of file hash, or null if file cannot be read\r\n */\r\nasync function getFileHash(filePath: string): Promise<string | null> {\r\n  try {\r\n    const content = await readFile(filePath);\r\n    return createHash(\"sha256\").update(content).digest(\"hex\");\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Copy statusline script to ~/.claude-zest/ if needed\r\n * Only copies if file doesn't exist or content hash changed (script was updated)\r\n * Uses hash comparison instead of size to avoid TOCTOU race conditions\r\n */\r\nexport async function ensureStatuslineScript(): Promise<void> {\r\n  try {\r\n    const __dirname = dirname(fileURLToPath(import.meta.url));\r\n    const sourceStatusline = join(__dirname, \"..\", \"statusline\", \"statusline-cli.js\");\r\n    const targetStatusline = STATUSLINE_SCRIPT_PATH;\r\n\r\n    await ensureDirectory(CLAUDE_ZEST_DIR);\r\n\r\n    // Verify source file exists before attempting copy\r\n    try {\r\n      await stat(sourceStatusline);\r\n    } catch (error) {\r\n      logger.error(\"Statusline source script not found\", {\r\n        expectedPath: sourceStatusline,\r\n        error,\r\n      });\r\n      throw new Error(`Statusline script not found at ${sourceStatusline}`);\r\n    }\r\n\r\n    // Check if we need to copy (using hash comparison to prevent race conditions)\r\n    const sourceHash = await getFileHash(sourceStatusline);\r\n    const targetHash = await getFileHash(targetStatusline);\r\n\r\n    // Copy if hashes differ or target doesn't exist\r\n    const shouldCopy = sourceHash !== targetHash;\r\n\r\n    if (shouldCopy) {\r\n      await copyFile(sourceStatusline, targetStatusline);\r\n      logger.debug(\"Statusline script copied\", {\r\n        source: sourceStatusline,\r\n        target: STATUSLINE_SCRIPT_PATH,\r\n        sourceHash,\r\n        targetHash: targetHash || \"not-found\",\r\n      });\r\n    } else {\r\n      logger.debug(\"Statusline script up to date, skipping copy\");\r\n    }\r\n  } catch (error) {\r\n    // Non-critical - statusline just won't work\r\n    logger.warn(\"Failed to copy statusline script\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * Check for plugin updates and cache results for statusline\r\n * Non-blocking operation - logs errors but never throws\r\n */\r\nexport async function checkAndCachePluginUpdates(): Promise<void> {\r\n  try {\r\n    await ensureDirectory(CLAUDE_ZEST_DIR);\r\n    const updateCheckResult = await checkForUpdates();\r\n\r\n    // Write result to cache file for statusline to read\r\n    await writeVersionCheck({\r\n      updateAvailable: updateCheckResult.updateAvailable,\r\n      currentVersion: updateCheckResult.currentVersion,\r\n      latestVersion: updateCheckResult.latestVersion,\r\n      checkedAt: Date.now(),\r\n    });\r\n\r\n    if (updateCheckResult.error) {\r\n      // Error occurred during check - log only\r\n      // Check if version checking is disabled (URL not configured)\r\n      if (updateCheckResult.error.includes(\"not configured\")) {\r\n        logger.debug(\"Version checking disabled - marketplace URL not configured\");\r\n      } else {\r\n        logger.warn(\"Version check failed\", {\r\n          error: updateCheckResult.error,\r\n          currentVersion: updateCheckResult.currentVersion,\r\n        });\r\n      }\r\n    } else if (updateCheckResult.updateAvailable) {\r\n      // Update available - cache for statusline to display\r\n      logger.info(\"Plugin update available - will show in statusline\", {\r\n        currentVersion: updateCheckResult.currentVersion,\r\n        latestVersion: updateCheckResult.latestVersion,\r\n      });\r\n    } else {\r\n      // Up-to-date - silent to user, log only\r\n      logger.info(\"Plugin is up-to-date\", {\r\n        version: updateCheckResult.currentVersion,\r\n      });\r\n    }\r\n  } catch (error) {\r\n    // Catch any unexpected errors to prevent hook failure\r\n    logger.error(\"Unexpected error during version check\", error);\r\n    // Silent to user - don't disrupt session start\r\n  }\r\n}\r\n",
    "/**\r\n * Application constants and configuration values\r\n */\r\n\r\nimport { homedir } from \"node:os\";\r\nimport { join } from \"node:path\";\r\n\r\n// Claude Code directories\r\n// Respects CLAUDE_INSTALL_PATH environment variable for non-standard installations\r\nexport const CLAUDE_INSTALL_DIR = process.env.CLAUDE_INSTALL_PATH || join(homedir(), \".claude\");\r\nexport const CLAUDE_PROJECTS_DIR = join(CLAUDE_INSTALL_DIR, \"projects\");\r\nexport const CLAUDE_SETTINGS_FILE = join(CLAUDE_INSTALL_DIR, \"settings.json\");\r\n\r\n// Base directories\r\nexport const CLAUDE_ZEST_DIR = join(CLAUDE_INSTALL_DIR, \"..\", \".claude-zest\");\r\nexport const QUEUE_DIR = join(CLAUDE_ZEST_DIR, \"queue\");\r\nexport const LOGS_DIR = join(CLAUDE_ZEST_DIR, \"logs\");\r\nexport const STATE_DIR = join(CLAUDE_ZEST_DIR, \"state\");\r\nexport const DELETION_CACHE_DIR = join(CLAUDE_ZEST_DIR, \"cache\", \"deletions\");\r\n\r\n// File paths\r\nexport const SESSION_FILE = join(CLAUDE_ZEST_DIR, \"session.json\"); // Auth session + workspace info\r\nexport const SETTINGS_FILE = join(CLAUDE_ZEST_DIR, \"settings.json\"); // User preferences\r\nexport const DAEMON_PID_FILE = join(CLAUDE_ZEST_DIR, \"daemon.pid\");\r\nexport const STATUSLINE_SCRIPT_PATH = join(CLAUDE_ZEST_DIR, \"statusline.mjs\"); // Status line script (.mjs for ESM support)\r\nexport const STATUS_CACHE_FILE = join(CLAUDE_ZEST_DIR, \"status-cache.json\"); // Status cache for version checks and sync errors\r\n\r\n// Queue files\r\nexport const EVENTS_QUEUE_FILE = join(QUEUE_DIR, \"events.jsonl\");\r\nexport const SESSIONS_QUEUE_FILE = join(QUEUE_DIR, \"chat-sessions.jsonl\");\r\nexport const MESSAGES_QUEUE_FILE = join(QUEUE_DIR, \"chat-messages.jsonl\");\r\n\r\n// Platform and source identifiers\r\nexport const PLATFORM = \"terminal\";\r\nexport const SOURCE = \"claude-code\";\r\nexport const CLIENT_ID = \"claude-cli\";\r\n\r\n// Sync configuration\r\nexport const SYNC_INTERVAL_MS = 60000; // 60 seconds\r\nexport const MAX_RETRY_ATTEMPTS = 3;\r\nexport const RETRY_BACKOFF_MS = 5000;\r\n\r\n// File locking configuration\r\nexport const LOCK_RETRY_MS = 50; // Retry interval when lock is held by another process\r\nexport const LOCK_MAX_RETRIES = 300; // Max retries (10 seconds total)\r\n\r\n// Debounce configuration (prevents duplicate hook executions)\r\nexport const DEBOUNCE_DIR = join(CLAUDE_ZEST_DIR, \"debounce\");\r\nexport const DEBOUNCE_WINDOW_MS = 500; // First-wins debounce window\r\nexport const DEBOUNCE_TRAILING_MS = 300; // Trailing debounce: wait after last hook before processing\r\n\r\n// Delayed extraction configuration (for PostToolUse trailing debounce)\r\nexport const DELAYED_EXTRACTION_INITIAL_DELAY_MS = 500; // Initial wait before checking if hooks settled\r\nexport const DELAYED_EXTRACTION_MAX_WAIT_MS = 10000; // Maximum total wait time\r\nexport const DELAYED_EXTRACTION_CHECK_INTERVAL_MS = 300; // How often to check if hooks settled\r\n\r\n// Cache configuration\r\nexport const DELETION_CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\r\n\r\n// Log rotation configuration\r\nexport const LOG_RETENTION_DAYS = 7; // Delete log files older than 7 days\r\n\r\n// Authentication configuration\r\nexport const PROACTIVE_REFRESH_THRESHOLD_MS = 5 * 60 * 1000; // Proactively refresh JWT/access tokens 5 minutes before expiration\r\n\r\n// Content size limits\r\nexport const MAX_DIFF_SIZE_BYTES = 10 * 1024 * 1024; // 10MB\r\nexport const MAX_CONTENT_PREVIEW_LENGTH = 1000; // characters\r\nexport const MAX_SESSION_TITLE_LENGTH = 100; // characters\r\nexport const MIN_SESSION_TITLE_LENGTH = 3; // characters\r\n\r\n// Session quality filters\r\nexport const MIN_MESSAGES_PER_SESSION = 3; // Minimum messages required to upload a session\r\nexport const STALE_SESSION_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\r\n\r\n// API endpoints (configured from .env at build time)\r\n// Values are baked into the bundle during build\r\nexport const WEB_APP_URL = process.env.ZEST_WEB_APP_URL || \"http://localhost:3000\";\r\nexport const SUPABASE_URL = process.env.ZEST_SUPABASE_URL || \"\";\r\nexport const SUPABASE_ANON_KEY = process.env.ZEST_SUPABASE_ANON_KEY || \"\";\r\n\r\n// Filter patterns for commands/messages to exclude from tracking\r\nexport const EXCLUDED_COMMAND_PATTERNS = [\r\n  // Claude Code built-in commands\r\n  /^\\/(add-dir|agents|bashes|bug|clear|compact|config|context|cost|doctor|exit|export|help|hooks|ide|init|install-github-app|login|logout|mcp|memory|model|output-style|permissions|plugin|pr-comments|privacy-settings|release-notes|resume|review|rewind|sandbox|security-review|stats|status|statusline|terminal-setup|todos|usage|vim)\\b/i,\r\n\r\n  // Zest plugin commands (like /zest:status, /zest:login, etc.)\r\n  /^\\/zest[^:\\s]*:/i,\r\n\r\n  // Messages containing Zest command tags (e.g., <command-name>/zest:status</command-name>)\r\n  /<command-name>\\/zest[^<]*<\\/command-name>/i,\r\n\r\n  // Messages containing Zest CLI script paths (e.g., \"node .../dist/commands/sync-cli.js\")\r\n  /node\\s+.*\\/dist\\/commands\\/.*-cli\\.js/i,\r\n];\r\n\r\nexport const ZEST_SESSION_NAMESPACE = \"1b671a64-40d5-491e-99b0-da01ff1f3341\";\r\n\r\n// Version check configuration\r\n// If ZEST_MARKETPLACE_PLUGIN_JSON_URL is not set, version checking will be disabled\r\nexport const MARKETPLACE_PLUGIN_JSON_URL = process.env.ZEST_MARKETPLACE_PLUGIN_JSON_URL || \"\";\r\nexport const VERSION_CHECK_TIMEOUT_MS = 5000; // 5 seconds\r\nexport const UPDATE_CHECK_CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour - how long to cache update check results\r\n\r\n// Daemon management configuration\r\nexport const DAEMON_FRESH_PID_THRESHOLD_MS = 2000; // 2 seconds - how recently PID file must be modified to skip restart\r\n",
    "/**\r\n * Filesystem utility functions\r\n *\r\n * Shared helpers for file and directory operations\r\n *\r\n * Note: This module intentionally has no dependencies on logger.ts\r\n * to avoid circular dependencies (logger.ts uses ensureDirectory).\r\n */\r\n\r\nimport { mkdir, stat } from \"node:fs/promises\";\r\n\r\n/**\r\n * Ensure directory exists, creating it if necessary\r\n * Creates parent directories recursively with secure permissions (mode 0o700)\r\n *\r\n * @param dirPath - Path to the directory to ensure exists\r\n */\r\nexport async function ensureDirectory(dirPath: string): Promise<void> {\r\n  try {\r\n    await stat(dirPath);\r\n  } catch {\r\n    await mkdir(dirPath, { recursive: true, mode: 0o700 });\r\n  }\r\n}\r\n",
    "/**\r\n * Logging utilities\r\n *\r\n * Handles logging to console and file system with daily log rotation.\r\n * Log files are named with dates (e.g., plugin-2026-01-09.log) and\r\n * automatically cleaned up after LOG_RETENTION_DAYS.\r\n */\r\n\r\nimport { appendFile } from \"node:fs/promises\";\r\nimport { dirname } from \"node:path\";\r\nimport { ensureDirectory } from \"./fs-utils.js\";\r\nimport { cleanupStaleLogs, getDatedLogPath } from \"./log-rotation.js\";\r\n\r\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\r\n\r\nclass Logger {\r\n  private minLevel: LogLevel = \"info\";\r\n  private readonly logPrefix: string;\r\n\r\n  private levels: Record<LogLevel, number> = {\r\n    debug: 0,\r\n    info: 1,\r\n    warn: 2,\r\n    error: 3,\r\n  };\r\n\r\n  constructor(logPrefix = \"plugin\") {\r\n    this.logPrefix = logPrefix;\r\n  }\r\n\r\n  setLevel(level: LogLevel): void {\r\n    this.minLevel = level;\r\n  }\r\n\r\n  private async writeToFile(message: string): Promise<void> {\r\n    try {\r\n      // Get date-based log path (handles date rollover automatically)\r\n      const logFilePath = getDatedLogPath(this.logPrefix);\r\n      await ensureDirectory(dirname(logFilePath));\r\n      const timestamp = new Date().toISOString();\r\n      await appendFile(logFilePath, `[${timestamp}] ${message}\\n`, \"utf-8\");\r\n\r\n      // Trigger cleanup (throttled to once per hour)\r\n      cleanupStaleLogs(this.logPrefix);\r\n    } catch (error) {\r\n      // Silently fail - don't crash if we can't write logs\r\n      console.error(\"Failed to write to log file:\", error);\r\n    }\r\n  }\r\n\r\n  private shouldLog(level: LogLevel): boolean {\r\n    return this.levels[level] >= this.levels[this.minLevel];\r\n  }\r\n\r\n  debug(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"debug\")) {\r\n      // Only write to file, don't clutter console\r\n      this.writeToFile(`DEBUG: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  info(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"info\")) {\r\n      // Only write to file, don't clutter console\r\n      this.writeToFile(`INFO: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  warn(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"warn\")) {\r\n      // Show warnings to user\r\n      console.warn(`[Zest:Warn] ${message}`, ...args);\r\n      this.writeToFile(`WARN: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  error(message: string, error?: unknown): void {\r\n    if (this.shouldLog(\"error\")) {\r\n      // Show errors to user\r\n      console.error(`[Zest:Error] ${message}`, error);\r\n      this.writeToFile(\r\n        `ERROR: ${message} ${error instanceof Error ? error.stack : JSON.stringify(error)}`,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport const logger = new Logger();\r\n",
    "/**\r\n * Log rotation utilities\r\n *\r\n * Provides date-based log file paths and automatic cleanup of stale logs.\r\n */\r\n\r\nimport { readdir, unlink } from \"node:fs/promises\";\r\nimport { join } from \"node:path\";\r\nimport { LOG_RETENTION_DAYS, LOGS_DIR } from \"../config/constants.js\";\r\nimport { ensureDirectory } from \"./fs-utils.js\";\r\nimport { logger } from \"./logger.js\";\r\n\r\n// Throttle cleanup to run at most once per hour\r\nconst CLEANUP_THROTTLE_MS = 60 * 60 * 1000; // 1 hour\r\nlet lastCleanupTime: Record<string, number> = {};\r\n\r\n/**\r\n * Get current date string in YYYY-MM-DD format (UTC)\r\n */\r\nexport function getDateString(): string {\r\n  return new Date().toISOString().split(\"T\")[0];\r\n}\r\n\r\n/**\r\n * Get date-based log file path\r\n * @param logPrefix - Prefix for the log file (e.g., \"plugin\" or \"sync\")\r\n * @returns Full path like ~/.claude-zest/logs/plugin-2026-01-09.log\r\n */\r\nexport function getDatedLogPath(logPrefix: string): string {\r\n  const dateStr = getDateString();\r\n  return join(LOGS_DIR, `${logPrefix}-${dateStr}.log`);\r\n}\r\n\r\n/**\r\n * Parse date from log filename\r\n * @param filename - Filename like \"plugin-2026-01-09.log\"\r\n * @param logPrefix - Prefix to match (e.g., \"plugin\")\r\n * @returns Date object or null if doesn't match pattern\r\n */\r\nfunction parseDateFromFilename(filename: string, logPrefix: string): Date | null {\r\n  const pattern = new RegExp(`^${logPrefix}-(\\\\d{4}-\\\\d{2}-\\\\d{2})\\\\.log$`);\r\n  const match = filename.match(pattern);\r\n\r\n  if (!match) {\r\n    return null;\r\n  }\r\n\r\n  const date = new Date(match[1] + \"T00:00:00Z\");\r\n  return Number.isNaN(date.getTime()) ? null : date;\r\n}\r\n\r\n/**\r\n * Clean up stale log files older than retention period\r\n * Throttled to run at most once per hour per logPrefix\r\n *\r\n * @param logPrefix - Prefix of logs to clean (e.g., \"plugin\" or \"sync\")\r\n */\r\nexport async function cleanupStaleLogs(logPrefix: string): Promise<void> {\r\n  const now = Date.now();\r\n  const lastCleanup = lastCleanupTime[logPrefix] || 0;\r\n\r\n  // Throttle: skip if cleaned up less than an hour ago\r\n  if (now - lastCleanup < CLEANUP_THROTTLE_MS) {\r\n    return;\r\n  }\r\n\r\n  lastCleanupTime[logPrefix] = now;\r\n\r\n  try {\r\n    await ensureDirectory(LOGS_DIR);\r\n    const files = await readdir(LOGS_DIR);\r\n    const cutoffDate = new Date(now - LOG_RETENTION_DAYS * 24 * 60 * 60 * 1000);\r\n\r\n    for (const file of files) {\r\n      const fileDate = parseDateFromFilename(file, logPrefix);\r\n\r\n      if (fileDate && fileDate < cutoffDate) {\r\n        const filePath = join(LOGS_DIR, file);\r\n        try {\r\n          await unlink(filePath);\r\n        } catch (error) {\r\n          logger.error(`Failed to delete old log file ${file}`, error);\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    logger.error(\"Failed to cleanup old logs\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * Force cleanup regardless of throttle (for daemon startup)\r\n * @param logPrefix - Prefix of logs to clean (e.g., \"plugin\" or \"sync\")\r\n */\r\nexport async function forceCleanupStaleLogs(logPrefix: string): Promise<void> {\r\n  // Reset throttle to force cleanup\r\n  lastCleanupTime[logPrefix] = 0;\r\n  await cleanupStaleLogs(logPrefix);\r\n}\r\n",
    "/**\r\n * Plugin version utilities\r\n *\r\n * Reads version from plugin.json manifest and checks for updates\r\n */\r\n\r\nimport { readFileSync } from \"node:fs\";\r\nimport { join } from \"node:path\";\r\nimport {\r\n  CLAUDE_INSTALL_DIR,\r\n  MARKETPLACE_PLUGIN_JSON_URL,\r\n  VERSION_CHECK_TIMEOUT_MS,\r\n} from \"../config/constants.js\";\r\nimport { logger } from \"./logger.js\";\r\n\r\n/**\r\n * Structure of plugin.json from marketplace repository\r\n */\r\nexport interface MarketplacePluginJson {\r\n  version: string;\r\n  name?: string;\r\n  description?: string;\r\n  [key: string]: unknown; // Allow additional fields\r\n}\r\n\r\n/**\r\n * Result of version comparison\r\n */\r\nexport type VersionComparisonResult = \"newer\" | \"same\" | \"older\";\r\n\r\n/**\r\n * Result of update check operation\r\n */\r\nexport interface UpdateCheckResult {\r\n  updateAvailable: boolean;\r\n  currentVersion: string;\r\n  latestVersion: string;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Get the current plugin version from the marketplace plugin.json\r\n * @returns Plugin version string (e.g., \"0.0.7\") or \"unknown\" if unable to read\r\n */\r\nexport function getPluginVersion(): string {\r\n  try {\r\n    // Claude reads the version from the marketplace plugin.json\r\n    const marketplacePluginPath = join(\r\n      CLAUDE_INSTALL_DIR,\r\n      \"plugins\",\r\n      \"marketplaces\",\r\n      \"zest-marketplace\",\r\n      \"zest\",\r\n      \".claude-plugin\",\r\n      \"plugin.json\",\r\n    );\r\n\r\n    const pluginJson = JSON.parse(readFileSync(marketplacePluginPath, \"utf-8\"));\r\n\r\n    if (pluginJson.version && typeof pluginJson.version === \"string\") {\r\n      logger.debug(\"Read plugin version from marketplace plugin.json\", {\r\n        version: pluginJson.version,\r\n      });\r\n      return pluginJson.version;\r\n    }\r\n\r\n    logger.warn(\"Version field not found in marketplace plugin.json\");\r\n    return \"unknown\";\r\n  } catch (error) {\r\n    logger.warn(\"Failed to read plugin version from marketplace plugin.json\", error);\r\n    return \"unknown\";\r\n  }\r\n}\r\n\r\n/**\r\n * Fetch the latest plugin version from the marketplace repository\r\n * @returns Promise that resolves to version string (e.g., \"0.0.41\")\r\n * @throws Error if network request fails, times out, or response is malformed\r\n */\r\nexport async function fetchMarketplaceVersion(): Promise<string> {\r\n  logger.info(\"Fetching latest plugin version from marketplace\", {\r\n    url: MARKETPLACE_PLUGIN_JSON_URL,\r\n  });\r\n\r\n  // Create AbortController for timeout\r\n  const controller = new AbortController();\r\n  const timeoutId = setTimeout(() => {\r\n    controller.abort();\r\n    logger.warn(\"Marketplace version fetch timed out\", {\r\n      timeout_ms: VERSION_CHECK_TIMEOUT_MS,\r\n    });\r\n  }, VERSION_CHECK_TIMEOUT_MS);\r\n\r\n  try {\r\n    // Fetch plugin.json from marketplace\r\n    const response = await fetch(MARKETPLACE_PLUGIN_JSON_URL, {\r\n      signal: controller.signal,\r\n      headers: {\r\n        Accept: \"application/json\",\r\n        \"User-Agent\": \"zest-claude-plugin\",\r\n      },\r\n    });\r\n\r\n    // Check HTTP status\r\n    if (!response.ok) {\r\n      const error = new Error(\r\n        `Marketplace request failed: HTTP ${response.status} ${response.statusText}`,\r\n      );\r\n      logger.error(\"Failed to fetch marketplace version - HTTP error\", {\r\n        status: response.status,\r\n        statusText: response.statusText,\r\n        url: MARKETPLACE_PLUGIN_JSON_URL,\r\n      });\r\n      throw error;\r\n    }\r\n\r\n    // Parse JSON response\r\n    const data = (await response.json()) as MarketplacePluginJson;\r\n\r\n    // Validate version field exists\r\n    if (!data.version || typeof data.version !== \"string\") {\r\n      const error = new Error(\"Marketplace plugin.json missing or invalid version field\");\r\n      logger.error(\"Invalid marketplace plugin.json structure\", {\r\n        hasVersion: !!data.version,\r\n        versionType: typeof data.version,\r\n      });\r\n      throw error;\r\n    }\r\n\r\n    logger.info(\"Successfully fetched marketplace version\", {\r\n      version: data.version,\r\n    });\r\n\r\n    return data.version;\r\n  } catch (error) {\r\n    // Handle specific error types\r\n    if (error instanceof Error) {\r\n      if (error.name === \"AbortError\") {\r\n        throw new Error(`Marketplace version check timed out after ${VERSION_CHECK_TIMEOUT_MS}ms`);\r\n      }\r\n      // Re-throw other errors with context\r\n      throw error;\r\n    }\r\n    // Handle non-Error exceptions\r\n    throw new Error(`Unexpected error fetching marketplace version: ${error}`);\r\n  } finally {\r\n    // Clean up timeout\r\n    clearTimeout(timeoutId);\r\n  }\r\n}\r\n\r\n/**\r\n * Parse a semantic version string into components\r\n * @param version - Version string (e.g., \"0.0.8\" or \"1.2.3-beta\")\r\n * @returns Object with major, minor, patch numbers, or null if malformed\r\n */\r\nfunction parseVersion(version: string): {\r\n  major: number;\r\n  minor: number;\r\n  patch: number;\r\n} | null {\r\n  // Remove leading 'v' if present\r\n  const cleanVersion = version.startsWith(\"v\") ? version.slice(1) : version;\r\n\r\n  // Extract base version (before any pre-release tag like \"-beta\")\r\n  const baseVersion = cleanVersion.split(\"-\")[0];\r\n\r\n  // Split into parts and parse as integers\r\n  const parts = baseVersion.split(\".\");\r\n\r\n  if (parts.length < 1 || parts.length > 3) {\r\n    return null;\r\n  }\r\n\r\n  const major = Number.parseInt(parts[0], 10);\r\n  const minor = parts.length >= 2 ? Number.parseInt(parts[1], 10) : 0;\r\n  const patch = parts.length >= 3 ? Number.parseInt(parts[2], 10) : 0;\r\n\r\n  // Check if any part is NaN\r\n  if (Number.isNaN(major) || Number.isNaN(minor) || Number.isNaN(patch)) {\r\n    return null;\r\n  }\r\n\r\n  // Validate ranges - reject negative numbers\r\n  if (major < 0 || minor < 0 || patch < 0) {\r\n    return null;\r\n  }\r\n\r\n  // Validate ranges - reject unreasonably large version numbers (likely malformed)\r\n  if (major > 9999 || minor > 9999 || patch > 9999) {\r\n    return null;\r\n  }\r\n\r\n  return { major, minor, patch };\r\n}\r\n\r\n/**\r\n * Compare two semantic version strings\r\n * @param currentVersion - Current installed version (e.g., \"0.0.1\")\r\n * @param latestVersion - Latest available version (e.g., \"0.0.8\")\r\n * @returns \"newer\" if latest > current, \"same\" if equal, \"older\" if latest < current\r\n *\r\n * @example\r\n * compareVersions(\"0.0.1\", \"0.0.8\") // returns \"newer\"\r\n * compareVersions(\"0.0.8\", \"0.0.8\") // returns \"same\"\r\n * compareVersions(\"0.0.10\", \"0.0.8\") // returns \"older\"\r\n * compareVersions(\"0.1.0\", \"0.0.9\") // returns \"newer\"\r\n */\r\nexport function compareVersions(\r\n  currentVersion: string,\r\n  latestVersion: string,\r\n): VersionComparisonResult {\r\n  logger.debug(\"Comparing versions\", {\r\n    current: currentVersion,\r\n    latest: latestVersion,\r\n  });\r\n\r\n  // Parse both versions\r\n  const current = parseVersion(currentVersion);\r\n  const latest = parseVersion(latestVersion);\r\n\r\n  // Handle malformed versions\r\n  if (!current || !latest) {\r\n    logger.warn(\"Unable to compare versions - malformed version string\", {\r\n      current: currentVersion,\r\n      latest: latestVersion,\r\n      currentParsed: current,\r\n      latestParsed: latest,\r\n    });\r\n    // If we can't parse, treat as \"same\" to avoid false notifications\r\n    return \"same\";\r\n  }\r\n\r\n  // Compare major version\r\n  if (latest.major > current.major) {\r\n    return \"newer\";\r\n  }\r\n  if (latest.major < current.major) {\r\n    return \"older\";\r\n  }\r\n\r\n  // Major versions equal, compare minor version\r\n  if (latest.minor > current.minor) {\r\n    return \"newer\";\r\n  }\r\n  if (latest.minor < current.minor) {\r\n    return \"older\";\r\n  }\r\n\r\n  // Major and minor equal, compare patch version\r\n  if (latest.patch > current.patch) {\r\n    return \"newer\";\r\n  }\r\n  if (latest.patch < current.patch) {\r\n    return \"older\";\r\n  }\r\n\r\n  // All components equal\r\n  return \"same\";\r\n}\r\n\r\n/**\r\n * Check if a plugin update is available\r\n *\r\n * Orchestrates the full version check workflow:\r\n * 1. Gets current installed version from local plugin.json\r\n * 2. Fetches latest version from marketplace repository\r\n * 3. Compares versions to determine if update is available\r\n *\r\n * @returns Promise that resolves to UpdateCheckResult with status and version info\r\n *\r\n * @example\r\n * const result = await checkForUpdates();\r\n * if (result.updateAvailable) {\r\n *   console.log(`Update available: ${result.currentVersion} â†’ ${result.latestVersion}`);\r\n * }\r\n */\r\nexport async function checkForUpdates(): Promise<UpdateCheckResult> {\r\n  logger.info(\"Starting plugin update check\");\r\n\r\n  try {\r\n    // Step 1: Get current installed version\r\n    const currentVersion = getPluginVersion();\r\n\r\n    // Handle case where we can't read local version\r\n    if (currentVersion === \"unknown\") {\r\n      const error = \"Unable to determine current plugin version\";\r\n      logger.warn(error);\r\n      return {\r\n        updateAvailable: false,\r\n        currentVersion: \"unknown\",\r\n        latestVersion: \"unknown\",\r\n        error,\r\n      };\r\n    }\r\n\r\n    logger.info(\"Current plugin version\", { version: currentVersion });\r\n\r\n    // Step 2: Fetch latest version from marketplace\r\n    let latestVersion: string;\r\n    try {\r\n      latestVersion = await fetchMarketplaceVersion();\r\n    } catch (error) {\r\n      // Network or parsing error - return gracefully\r\n      const errorMessage = error instanceof Error ? error.message : String(error);\r\n      logger.warn(\"Failed to fetch marketplace version\", { error: errorMessage });\r\n      return {\r\n        updateAvailable: false,\r\n        currentVersion,\r\n        latestVersion: \"unknown\",\r\n        error: errorMessage,\r\n      };\r\n    }\r\n\r\n    // Step 3: Compare versions\r\n    const comparison = compareVersions(currentVersion, latestVersion);\r\n\r\n    // Determine if update is available\r\n    const updateAvailable = comparison === \"newer\";\r\n\r\n    logger.info(\"Version check complete\", {\r\n      currentVersion,\r\n      latestVersion,\r\n      comparison,\r\n      updateAvailable,\r\n    });\r\n\r\n    return {\r\n      updateAvailable,\r\n      currentVersion,\r\n      latestVersion,\r\n    };\r\n  } catch (error) {\r\n    // Catch any unexpected errors in the orchestration\r\n    const errorMessage = error instanceof Error ? error.message : String(error);\r\n    logger.error(\"Unexpected error during version check\", { error: errorMessage });\r\n\r\n    return {\r\n      updateAvailable: false,\r\n      currentVersion: \"unknown\",\r\n      latestVersion: \"unknown\",\r\n      error: `Version check failed: ${errorMessage}`,\r\n    };\r\n  }\r\n}\r\n",
    "/**\r\n * Status Cache Manager\r\n *\r\n * Manages a shared status cache file that stores:\r\n * - Version update check results\r\n * - Sync error state\r\n *\r\n * All write operations use file locking to prevent race conditions between\r\n * concurrent processes (daemon, session handlers, commands).\r\n */\r\n\r\nimport { readFileSync, writeFileSync } from \"node:fs\";\r\nimport { STATUS_CACHE_FILE } from \"../config/constants.js\";\r\nimport { withFileLock } from \"./file-lock.js\";\r\nimport { logger } from \"./logger.js\";\r\n\r\n/**\r\n * Sync error types - categorizes different failure modes\r\n */\r\nexport type SyncErrorType =\r\n  | \"not_authenticated\" // Auth token expired/missing - user needs to run /zest:login\r\n  | \"upload_failed\" // Upload to Supabase failed after retries\r\n  | \"network_error\" // Network connectivity issue\r\n  | \"daemon_not_running\" // Daemon process is not running\r\n  | \"daemon_restart_failed\"; // Daemon failed to restart\r\n\r\n/**\r\n * Version check data structure\r\n */\r\nexport interface VersionCheck {\r\n  updateAvailable: boolean;\r\n  currentVersion: string;\r\n  latestVersion: string;\r\n  checkedAt: number; // Unix timestamp\r\n}\r\n\r\n/**\r\n * Sync status data structure\r\n */\r\nexport interface SyncStatus {\r\n  hasError: boolean;\r\n  errorType: SyncErrorType | null;\r\n  errorMessage: string | null;\r\n  lastErrorAt: number | null; // Unix timestamp\r\n  lastSuccessAt: number | null; // Unix timestamp\r\n}\r\n\r\n/**\r\n * Complete status cache structure\r\n */\r\nexport interface StatusCache {\r\n  versionCheck: VersionCheck;\r\n  syncStatus: SyncStatus;\r\n}\r\n\r\n/**\r\n * Default version check state (no update available)\r\n */\r\nconst DEFAULT_VERSION_CHECK: VersionCheck = {\r\n  updateAvailable: false,\r\n  currentVersion: \"unknown\",\r\n  latestVersion: \"unknown\",\r\n  checkedAt: 0,\r\n};\r\n\r\n/**\r\n * Default sync status state (no error)\r\n */\r\nconst DEFAULT_SYNC_STATUS: SyncStatus = {\r\n  hasError: false,\r\n  errorType: null,\r\n  errorMessage: null,\r\n  lastErrorAt: null,\r\n  lastSuccessAt: null,\r\n};\r\n\r\n/**\r\n * Default status cache state\r\n */\r\nconst DEFAULT_STATUS_CACHE: StatusCache = {\r\n  versionCheck: DEFAULT_VERSION_CHECK,\r\n  syncStatus: DEFAULT_SYNC_STATUS,\r\n};\r\n\r\n/**\r\n * Read the status cache file\r\n * Handles migration from old flat structure to new nested structure\r\n * Returns defaults if file doesn't exist or is corrupted\r\n *\r\n * @returns StatusCache with defaults for missing fields\r\n */\r\nexport function readStatusCache(): StatusCache {\r\n  try {\r\n    const data = readFileSync(STATUS_CACHE_FILE, \"utf-8\");\r\n    const parsed = JSON.parse(data);\r\n\r\n    // Check if this is the old flat structure (from update-check.json)\r\n    // Old structure: { updateAvailable, currentVersion, latestVersion, checkedAt }\r\n    // New structure: { versionCheck: {...}, syncStatus: {...} }\r\n    if (parsed.updateAvailable !== undefined && !parsed.versionCheck) {\r\n      // Migration: convert old flat structure to new nested structure\r\n      logger.info(\"Migrating old update-check.json format to new status-cache.json format\");\r\n\r\n      const migrated: StatusCache = {\r\n        versionCheck: {\r\n          updateAvailable: parsed.updateAvailable ?? false,\r\n          currentVersion: parsed.currentVersion ?? \"unknown\",\r\n          latestVersion: parsed.latestVersion ?? \"unknown\",\r\n          checkedAt: parsed.checkedAt ?? 0,\r\n        },\r\n        syncStatus: DEFAULT_SYNC_STATUS,\r\n      };\r\n\r\n      return migrated;\r\n    }\r\n\r\n    // New structure - merge with defaults to handle missing fields\r\n    return {\r\n      versionCheck: {\r\n        ...DEFAULT_VERSION_CHECK,\r\n        ...parsed.versionCheck,\r\n      },\r\n      syncStatus: {\r\n        ...DEFAULT_SYNC_STATUS,\r\n        ...parsed.syncStatus,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    // File doesn't exist or is corrupted - return defaults\r\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\r\n      logger.debug(\"Status cache file does not exist, using defaults\");\r\n    } else {\r\n      logger.warn(\"Failed to read status cache file, using defaults\", error);\r\n    }\r\n    return DEFAULT_STATUS_CACHE;\r\n  }\r\n}\r\n\r\n/**\r\n * Write version check data to the status cache\r\n * Preserves existing sync status data\r\n * Uses file locking to prevent race conditions\r\n *\r\n * Note: Errors are logged but not thrown to avoid disrupting caller workflows\r\n *\r\n * @param check - Version check data to write\r\n */\r\nexport async function writeVersionCheck(check: VersionCheck): Promise<void> {\r\n  try {\r\n    await withFileLock(STATUS_CACHE_FILE, async () => {\r\n      // Read current cache inside lock\r\n      const currentCache = readStatusCache();\r\n\r\n      // Update only the version check section\r\n      const updatedCache: StatusCache = {\r\n        ...currentCache,\r\n        versionCheck: check,\r\n      };\r\n\r\n      // Write back to file\r\n      writeFileSync(STATUS_CACHE_FILE, JSON.stringify(updatedCache, null, 2), \"utf-8\");\r\n\r\n      logger.debug(\"Wrote version check to status cache\", {\r\n        updateAvailable: check.updateAvailable,\r\n        currentVersion: check.currentVersion,\r\n        latestVersion: check.latestVersion,\r\n      });\r\n    });\r\n  } catch (error) {\r\n    // Log error but don't throw to avoid disrupting caller workflows\r\n    logger.error(\"Failed to write version check to status cache\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * Write sync status data to the status cache\r\n * Preserves existing version check data\r\n * Uses file locking to prevent race conditions\r\n *\r\n * Note: Errors are logged but not thrown to avoid disrupting caller workflows\r\n *\r\n * @param status - Sync status data to write\r\n */\r\nexport async function writeSyncStatus(status: SyncStatus): Promise<void> {\r\n  try {\r\n    await withFileLock(STATUS_CACHE_FILE, async () => {\r\n      // Read current cache inside lock\r\n      const currentCache = readStatusCache();\r\n\r\n      // Update only the sync status section\r\n      const updatedCache: StatusCache = {\r\n        ...currentCache,\r\n        syncStatus: status,\r\n      };\r\n\r\n      // Write back to file\r\n      writeFileSync(STATUS_CACHE_FILE, JSON.stringify(updatedCache, null, 2), \"utf-8\");\r\n\r\n      logger.debug(\"Wrote sync status to status cache\", {\r\n        hasError: status.hasError,\r\n        errorType: status.errorType,\r\n      });\r\n    });\r\n  } catch (error) {\r\n    // Log error but don't throw to avoid disrupting caller workflows\r\n    logger.error(\"Failed to write sync status to status cache\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * Clear sync error status (called on successful sync)\r\n * Updates lastSuccessAt timestamp and clears error state\r\n * Uses file locking to prevent race conditions\r\n *\r\n * Note: Errors are logged but not thrown to avoid disrupting caller workflows\r\n */\r\nexport async function clearSyncError(): Promise<void> {\r\n  try {\r\n    await withFileLock(STATUS_CACHE_FILE, async () => {\r\n      // Read current cache inside lock\r\n      const currentCache = readStatusCache();\r\n\r\n      // Clear error state and update lastSuccessAt\r\n      const clearedStatus: SyncStatus = {\r\n        hasError: false,\r\n        errorType: null,\r\n        errorMessage: null,\r\n        lastErrorAt: currentCache.syncStatus.lastErrorAt, // Preserve for debugging\r\n        lastSuccessAt: Date.now(),\r\n      };\r\n\r\n      const updatedCache: StatusCache = {\r\n        ...currentCache,\r\n        syncStatus: clearedStatus,\r\n      };\r\n\r\n      // Write back to file\r\n      writeFileSync(STATUS_CACHE_FILE, JSON.stringify(updatedCache, null, 2), \"utf-8\");\r\n\r\n      logger.debug(\"Cleared sync error in status cache\");\r\n    });\r\n  } catch (error) {\r\n    // Log error but don't throw to avoid disrupting caller workflows\r\n    logger.error(\"Failed to clear sync error in status cache\", error);\r\n  }\r\n}\r\n",
    "/**\r\n * Cross-process file locking utility\r\n *\r\n * Provides file-based locking to prevent corruption from concurrent access\r\n * across different processes (plugin hooks vs daemon)\r\n *\r\n * Uses PID-based stale lock detection - a lock is only considered stale\r\n * if the owning process is dead, allowing long-running operations.\r\n */\r\n\r\nimport { unlinkSync } from \"node:fs\";\r\nimport { readdir, readFile, unlink, writeFile } from \"node:fs/promises\";\r\nimport { dirname } from \"node:path\";\r\nimport { LOCK_MAX_RETRIES, LOCK_RETRY_MS, QUEUE_DIR } from \"../config/constants.js\";\r\nimport { isProcessRunning } from \"./daemon-manager.js\";\r\nimport { ensureDirectory } from \"./fs-utils.js\";\r\nimport { logger } from \"./logger.js\";\r\n\r\n/**\r\n * Lock file metadata - stored in .lock files\r\n */\r\ninterface LockInfo {\r\n  pid: number;\r\n  timestamp: number; // For debugging/logging only - PID is authoritative\r\n}\r\n\r\n// Track active lock files for cleanup on process exit\r\nconst activeLockFiles = new Set<string>();\r\n\r\n/**\r\n * Check if a lock file represents a stale lock\r\n * A lock is stale ONLY if the owning process is dead\r\n * This ensures long-running operations (like uploads) don't have their locks stolen\r\n */\r\nfunction isLockStale(lockInfo: LockInfo): boolean {\r\n  return !isProcessRunning(lockInfo.pid);\r\n}\r\n\r\n/**\r\n * Acquire a file-based lock (cross-process safe)\r\n * Uses atomic file creation with 'wx' flag to prevent race conditions\r\n *\r\n * @returns true if lock was acquired, false if held by another active process\r\n */\r\nasync function acquireFileLock(filePath: string): Promise<boolean> {\r\n  const lockFile = `${filePath}.lock`;\r\n  const lockInfo: LockInfo = {\r\n    pid: process.pid,\r\n    timestamp: Date.now(),\r\n  };\r\n\r\n  try {\r\n    // Ensure parent directory exists before creating lock file\r\n    await ensureDirectory(dirname(lockFile));\r\n\r\n    // 'wx' flag = exclusive create - fails atomically if file already exists\r\n    await writeFile(lockFile, JSON.stringify(lockInfo), { flag: \"wx\" });\r\n    activeLockFiles.add(lockFile);\r\n    return true;\r\n  } catch (error) {\r\n    if ((error as NodeJS.ErrnoException).code !== \"EEXIST\") {\r\n      // Log more context for directory-related errors\r\n      const errCode = (error as NodeJS.ErrnoException).code;\r\n      if (errCode === \"ENOENT\" || errCode === \"EACCES\") {\r\n        logger.error(`Failed to create lock file ${lockFile}:`, error);\r\n      }\r\n      throw error; // Unexpected error - rethrow\r\n    }\r\n\r\n    // Lock file exists - check if it's stale (owning process is dead)\r\n    try {\r\n      const content = await readFile(lockFile, \"utf8\");\r\n      const existingLock: LockInfo = JSON.parse(content);\r\n\r\n      if (isLockStale(existingLock)) {\r\n        // Remove stale lock and retry\r\n        logger.debug(`Removing stale lock for ${filePath} (PID ${existingLock.pid} is dead)`);\r\n        await unlink(lockFile).catch(() => {});\r\n        return acquireFileLock(filePath); // Recursive retry\r\n      }\r\n    } catch {\r\n      // Couldn't read/parse lock file - it may be corrupted or being written\r\n      // Remove it and retry\r\n      logger.debug(`Lock file for ${filePath} is corrupted or unreadable, removing`);\r\n      await unlink(lockFile).catch(() => {});\r\n      return acquireFileLock(filePath);\r\n    }\r\n\r\n    return false; // Lock is held by an active process\r\n  }\r\n}\r\n\r\n/**\r\n * Release a file-based lock\r\n */\r\nasync function releaseFileLock(filePath: string): Promise<void> {\r\n  const lockFile = `${filePath}.lock`;\r\n  activeLockFiles.delete(lockFile);\r\n  await unlink(lockFile).catch(() => {}); // Ignore errors - file might already be gone\r\n}\r\n\r\n/**\r\n * Cleanup handler for graceful shutdown\r\n * Removes any lock files this process holds\r\n */\r\nfunction cleanupLockFiles(): void {\r\n  for (const lockFile of activeLockFiles) {\r\n    try {\r\n      unlinkSync(lockFile); // Must be sync in exit handler\r\n    } catch {\r\n      // Ignore errors during cleanup\r\n    }\r\n  }\r\n  activeLockFiles.clear();\r\n}\r\n\r\n/**\r\n * Clean up any stale lock files in the queue directory\r\n * Called during daemon restart to remove orphaned locks from crashed processes\r\n */\r\nexport async function cleanupStaleLocks(): Promise<void> {\r\n  try {\r\n    const files = await readdir(QUEUE_DIR).catch(() => [] as string[]);\r\n    const lockFiles = files.filter((f) => f.endsWith(\".lock\"));\r\n\r\n    for (const lockFileName of lockFiles) {\r\n      const lockFile = `${QUEUE_DIR}/${lockFileName}`;\r\n      try {\r\n        const content = await readFile(lockFile, \"utf8\");\r\n        const lockInfo: LockInfo = JSON.parse(content);\r\n\r\n        if (!isProcessRunning(lockInfo.pid)) {\r\n          await unlink(lockFile);\r\n          logger.info(`Cleaned up stale lock file: ${lockFileName} (PID ${lockInfo.pid} is dead)`);\r\n        }\r\n      } catch {\r\n        // Corrupted lock file - remove it\r\n        await unlink(lockFile).catch(() => {});\r\n        logger.info(`Removed corrupted lock file: ${lockFileName}`);\r\n      }\r\n    }\r\n  } catch (error) {\r\n    logger.debug(\"Failed to clean up stale locks:\", error);\r\n  }\r\n}\r\n\r\n// Set up cleanup handlers for graceful shutdown\r\nlet cleanupRegistered = false;\r\n\r\n/**\r\n * Register process exit handlers to clean up lock files\r\n * Safe to call multiple times - only registers once\r\n */\r\nexport function setupLockCleanup(): void {\r\n  if (cleanupRegistered) return;\r\n  cleanupRegistered = true;\r\n\r\n  process.on(\"exit\", cleanupLockFiles);\r\n  process.on(\"SIGINT\", () => {\r\n    cleanupLockFiles();\r\n    process.exit(0);\r\n  });\r\n  process.on(\"SIGTERM\", () => {\r\n    cleanupLockFiles();\r\n    process.exit(0);\r\n  });\r\n\r\n  logger.debug(\"Lock cleanup handlers registered\");\r\n}\r\n\r\n/**\r\n * Execute a function with exclusive file-based lock\r\n * Provides cross-process protection for file operations\r\n *\r\n * @param filePath - Path to the file to lock (creates filePath.lock)\r\n * @param fn - Function to execute while holding the lock\r\n * @returns The result of the function\r\n * @throws Error if lock cannot be acquired after max retries\r\n */\r\nexport async function withFileLock<T>(filePath: string, fn: () => Promise<T>): Promise<T> {\r\n  // Acquire file-based lock with retry\r\n  let retries = 0;\r\n  while (!(await acquireFileLock(filePath))) {\r\n    if (++retries >= LOCK_MAX_RETRIES) {\r\n      throw new Error(`Failed to acquire lock for ${filePath} after ${retries} retries`);\r\n    }\r\n    await new Promise((resolve) => setTimeout(resolve, LOCK_RETRY_MS));\r\n  }\r\n\r\n  try {\r\n    return await fn();\r\n  } finally {\r\n    await releaseFileLock(filePath);\r\n  }\r\n}\r\n",
    "/**\r\n * Daemon lifecycle management\r\n *\r\n * Handles PID tracking, daemon startup, and process detection\r\n */\r\n\r\nimport { exec, spawn } from \"node:child_process\";\r\nimport { readFileSync } from \"node:fs\";\r\nimport { readFile, stat, unlink, writeFile } from \"node:fs/promises\";\r\nimport { dirname, join } from \"node:path\";\r\nimport { fileURLToPath } from \"node:url\";\r\nimport { promisify } from \"node:util\";\r\nimport {\r\n  CLAUDE_ZEST_DIR,\r\n  DAEMON_FRESH_PID_THRESHOLD_MS,\r\n  DAEMON_PID_FILE,\r\n} from \"../config/constants.js\";\r\nimport { cleanupStaleLocks, withFileLock } from \"./file-lock.js\";\r\nimport { ensureDirectory } from \"./fs-utils.js\";\r\nimport { logger } from \"./logger.js\";\r\n\r\n// Lock file to prevent concurrent daemon restarts\r\nconst DAEMON_RESTART_LOCK = join(CLAUDE_ZEST_DIR, \"daemon-restart.lock\");\r\n\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = dirname(__filename);\r\n\r\n/**\r\n * Check if a process is running (cross-platform)\r\n * Uses signal 0 which checks existence without actually sending a signal\r\n */\r\nexport function isProcessRunning(pid: number): boolean {\r\n  try {\r\n    process.kill(pid, 0);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Start the sync daemon as a detached background process\r\n */\r\nexport async function startDaemon(): Promise<boolean> {\r\n  try {\r\n    // Find the daemon script path\r\n    const daemonScript = join(__dirname, \"..\", \"sync-daemon.js\");\r\n\r\n    // Spawn daemon as detached background process\r\n    const daemon = spawn(process.execPath, [daemonScript], {\r\n      detached: true, // Run independently\r\n      stdio: \"ignore\", // Don't capture output\r\n      windowsHide: true, // Hide console window on Windows\r\n    });\r\n\r\n    // Unref so parent can exit without waiting for daemon\r\n    daemon.unref();\r\n\r\n    // Daemon writes its own PID file when it starts\r\n    // Wait a moment to ensure it's written\r\n    await new Promise((resolve) => setTimeout(resolve, 100));\r\n\r\n    return true;\r\n  } catch (error) {\r\n    logger.error(\"Failed to start daemon:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Kill all running sync-daemon processes\r\n * This ensures we don't accumulate zombie daemons\r\n */\r\nasync function killAllDaemons(): Promise<void> {\r\n  try {\r\n    // First try to kill the daemon from PID file\r\n    const pid = await getDaemonPid();\r\n    if (pid) {\r\n      try {\r\n        process.kill(pid, \"SIGTERM\");\r\n      } catch {\r\n        // Process might not exist\r\n      }\r\n    }\r\n\r\n    // Also try to kill any other sync-daemon processes using pkill\r\n    // This catches zombies that weren't tracked in PID file\r\n    const execAsync = promisify(exec);\r\n\r\n    try {\r\n      // Kill all sync-daemon.js processes (excluding our own process)\r\n      await execAsync(`pkill -f 'sync-daemon.js' 2>/dev/null || true`);\r\n    } catch {\r\n      // pkill might not find any processes, which is fine\r\n    }\r\n\r\n    // Wait for processes to terminate\r\n    await new Promise((resolve) => setTimeout(resolve, 500));\r\n\r\n    // Clean up PID file\r\n    await cleanupPidFile();\r\n  } catch (error) {\r\n    logger.warn(\"Error during daemon cleanup:\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * Restart daemon - kills ALL existing daemons and starts a fresh one\r\n * Uses file locking to prevent multiple hooks from starting multiple daemons\r\n */\r\nexport async function restartDaemon(): Promise<boolean> {\r\n  try {\r\n    // Use file lock to ensure only ONE process can restart the daemon at a time\r\n    return await withFileLock(DAEMON_RESTART_LOCK, async () => {\r\n      // Check if a daemon was JUST started (within threshold)\r\n      // This prevents the second hook from killing the daemon the first hook just started\r\n      const existingPid = await getDaemonPid();\r\n      if (existingPid) {\r\n        try {\r\n          const pidFileStat = await stat(DAEMON_PID_FILE);\r\n          const ageMs = Date.now() - pidFileStat.mtimeMs;\r\n\r\n          if (ageMs < DAEMON_FRESH_PID_THRESHOLD_MS) {\r\n            // PID file is fresh - daemon was just started by another hook\r\n            return true;\r\n          }\r\n        } catch {\r\n          // Ignore errors checking PID file age\r\n        }\r\n      }\r\n\r\n      // Kill ALL existing daemon processes (not just the one in PID file)\r\n      await killAllDaemons();\r\n\r\n      // Clean up any stale lock files from crashed processes\r\n      await cleanupStaleLocks();\r\n\r\n      // Start new daemon\r\n      return await startDaemon();\r\n    });\r\n  } catch (error) {\r\n    logger.error(\"Failed to restart daemon:\", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Clean up stale PID file\r\n */\r\nasync function cleanupPidFile(): Promise<void> {\r\n  try {\r\n    await unlink(DAEMON_PID_FILE);\r\n  } catch {\r\n    // Ignore errors - file might not exist\r\n  }\r\n}\r\n\r\n/**\r\n * Write PID to daemon.pid file\r\n * Called by the daemon itself when it starts\r\n */\r\nexport async function writePidFile(pid: number): Promise<void> {\r\n  try {\r\n    await ensureDirectory(dirname(DAEMON_PID_FILE));\r\n    await writeFile(DAEMON_PID_FILE, pid.toString(), \"utf-8\");\r\n    logger.debug(`Wrote PID ${pid} to daemon.pid`);\r\n  } catch (error) {\r\n    logger.error(\"Failed to write PID file:\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * Get daemon PID (if running)\r\n */\r\nexport async function getDaemonPid(): Promise<number | null> {\r\n  try {\r\n    const pidData = await readFile(DAEMON_PID_FILE, \"utf-8\");\r\n    const pid = Number.parseInt(pidData.trim(), 10);\r\n\r\n    if (Number.isNaN(pid)) {\r\n      return null;\r\n    }\r\n\r\n    // Verify process exists\r\n    return isProcessRunning(pid) ? pid : null;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Check if daemon is running (synchronous version for statusline)\r\n * Verifies both PID file existence and process health\r\n */\r\nexport function isDaemonRunning(): boolean {\r\n  try {\r\n    const pidData = readFileSync(DAEMON_PID_FILE, \"utf-8\");\r\n    const pidStr = pidData.trim();\r\n\r\n    // Check for empty PID file\r\n    if (!pidStr) {\r\n      return false;\r\n    }\r\n\r\n    const pid = Number.parseInt(pidStr, 10);\r\n\r\n    // Check for invalid PID (NaN or non-positive)\r\n    if (Number.isNaN(pid) || pid <= 0) {\r\n      return false;\r\n    }\r\n\r\n    // Verify process exists\r\n    return isProcessRunning(pid);\r\n  } catch {\r\n    // PID file doesn't exist or can't be read\r\n    return false;\r\n  }\r\n}\r\n"
  ],
  "mappings": "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",
  "debugId": "E5E38D3DE5614D0364756E2164756E21",
  "names": []
}