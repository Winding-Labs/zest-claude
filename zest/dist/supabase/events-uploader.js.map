{
  "version": 3,
  "sources": ["../src/auth/session-manager.ts", "../src/config/constants.ts", "../src/utils/logger.ts", "../src/utils/queue-manager.ts", "../../../node_modules/uuid/dist/esm/regex.js", "../../../node_modules/uuid/dist/esm/validate.js", "../../../node_modules/uuid/dist/esm/parse.js", "../../../node_modules/uuid/dist/esm/stringify.js", "../../../node_modules/uuid/dist/esm/v35.js", "../../../node_modules/uuid/dist/esm/sha1.js", "../../../node_modules/uuid/dist/esm/v5.js", "../src/utils/uuid-converter.ts", "../src/supabase/events-uploader.ts"],
  "sourcesContent": [
    "/**\n * Session management\n *\n * Handles session persistence, validation, and token refresh\n */\n\nimport { mkdir, readFile, unlink, writeFile } from \"node:fs/promises\";\nimport { dirname } from \"node:path\";\nimport { PROACTIVE_REFRESH_THRESHOLD_MS, SESSION_FILE, WEB_APP_URL } from \"../config/constants.js\";\nimport { logger } from \"../utils/logger.js\";\n\nexport interface AuthSession {\n  accessToken: string;\n  refreshToken: string;\n  expiresAt: number; // Access token expiration (milliseconds)\n  refreshTokenExpiresAt?: number; // Refresh token expiration (milliseconds) - optional for backward compatibility\n  userId: string;\n  email: string;\n  workspaceId?: string;\n  workspaceName?: string;\n}\n\n/**\n * Load session from file\n */\nexport async function loadSession(): Promise<AuthSession | null> {\n  try {\n    const content = await readFile(SESSION_FILE, \"utf-8\");\n    const session = JSON.parse(content) as AuthSession;\n\n    // Validate session structure\n    if (\n      !session.accessToken ||\n      !session.refreshToken ||\n      !session.expiresAt ||\n      !session.userId ||\n      !session.email\n    ) {\n      logger.warn(\"Invalid session structure, clearing session\");\n      await clearSession();\n      return null;\n    }\n\n    const now = Date.now();\n\n    // Check if refresh token is expired (only if expiration is set - many configs have refresh tokens that never expire)\n    if (session.refreshTokenExpiresAt && session.refreshTokenExpiresAt < now) {\n      logger.warn(\"Refresh token expired, user must re-authenticate\");\n      await clearSession();\n      return null;\n    }\n\n    // Check if access token is expired\n    if (session.expiresAt < now) {\n      logger.debug(\"Access token expired, attempting refresh\");\n      try {\n        return await refreshSession(session);\n      } catch (error) {\n        logger.warn(\"Failed to refresh session\", error);\n        await clearSession();\n        return null;\n      }\n    }\n\n    return session;\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\n      // File doesn't exist - not an error\n      return null;\n    }\n    logger.error(\"Failed to load session\", error);\n    return null;\n  }\n}\n\n/**\n * Save session to file with secure permissions\n */\nexport async function saveSession(session: AuthSession): Promise<void> {\n  try {\n    // Ensure directory exists\n    await mkdir(dirname(SESSION_FILE), { recursive: true, mode: 0o700 });\n\n    // Write session file\n    await writeFile(SESSION_FILE, JSON.stringify(session, null, 2), {\n      encoding: \"utf-8\",\n      mode: 0o600, // Readable/writable by owner only\n    });\n\n    logger.info(\"Session saved successfully\");\n  } catch (error) {\n    logger.error(\"Failed to save session\", error);\n    throw error;\n  }\n}\n\n/**\n * Clear session file\n */\nexport async function clearSession(): Promise<void> {\n  try {\n    await unlink(SESSION_FILE);\n    logger.info(\"Session cleared successfully\");\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\n      // File doesn't exist - not an error\n      return;\n    }\n    logger.error(\"Failed to clear session\", error);\n    throw error;\n  }\n}\n\n/**\n * Refresh an expired session using the refresh token\n */\nexport async function refreshSession(session: AuthSession): Promise<AuthSession> {\n  try {\n    logger.debug(\"Refreshing session\");\n\n    const response = await fetch(`${WEB_APP_URL}/api/auth/extension/refresh`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        refreshToken: session.refreshToken,\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Token refresh failed: ${response.status} ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as {\n      accessToken: string;\n      refreshToken: string;\n      expiresIn: number; // seconds until access token expiration\n      refreshTokenExpiresIn?: number; // seconds until refresh token expiration\n    };\n\n    // Use actual expiration from Supabase (convert seconds to milliseconds)\n    const now = Date.now();\n    const expiresAt = now + data.expiresIn * 1000;\n\n    // Calculate refresh token expiration (if provided, otherwise keep existing or undefined for \"never expires\")\n    const refreshTokenExpiresAt = data.refreshTokenExpiresIn\n      ? now + data.refreshTokenExpiresIn * 1000\n      : session.refreshTokenExpiresAt; // Keep existing or undefined (never expires)\n\n    const newSession: AuthSession = {\n      ...session,\n      accessToken: data.accessToken,\n      refreshToken: data.refreshToken,\n      expiresAt,\n      refreshTokenExpiresAt,\n    };\n\n    logger.debug(\n      `Access token will expire in ${data.expiresIn} seconds (${new Date(expiresAt).toISOString()})`,\n    );\n    if (refreshTokenExpiresAt) {\n      logger.debug(`Refresh token will expire at ${new Date(refreshTokenExpiresAt).toISOString()}`);\n    } else {\n      logger.debug(\"Refresh token does not expire\");\n    }\n\n    await saveSession(newSession);\n    logger.info(\"Session refreshed successfully\");\n\n    return newSession;\n  } catch (error) {\n    logger.error(\"Failed to refresh session\", error);\n    throw error;\n  }\n}\n\n/**\n * Check if user is currently authenticated\n */\nexport async function isAuthenticated(): Promise<boolean> {\n  const session = await loadSession();\n  return session !== null && session.expiresAt > Date.now();\n}\n\n/**\n * Get current session (refresh if needed)\n *\n * Proactively refreshes tokens 5 minutes before expiration\n */\nexport async function getValidSession(): Promise<AuthSession | null> {\n  const session = await loadSession();\n  if (!session) {\n    return null;\n  }\n\n  const now = Date.now();\n  const timeUntilExpiration = session.expiresAt - now;\n\n  // Refresh if expired or expiring soon (within 5 minutes)\n  if (timeUntilExpiration < PROACTIVE_REFRESH_THRESHOLD_MS) {\n    try {\n      logger.debug(\n        `Token ${timeUntilExpiration < 0 ? \"expired\" : `expiring in ${Math.round(timeUntilExpiration / 1000)}s`}, refreshing...`,\n      );\n      return await refreshSession(session);\n    } catch (error) {\n      logger.warn(\"Failed to refresh session\", error);\n      return null; // Can't use expired/expiring session\n    }\n  }\n\n  return session;\n}\n",
    "/**\n * Application constants and configuration values\n */\n\nimport { homedir } from \"node:os\";\nimport { join } from \"node:path\";\n\n// Base directories\nexport const CLAUDE_ZEST_DIR = join(homedir(), \".claude-zest\");\nexport const QUEUE_DIR = join(CLAUDE_ZEST_DIR, \"queue\");\nexport const LOGS_DIR = join(CLAUDE_ZEST_DIR, \"logs\");\nexport const STATE_DIR = join(CLAUDE_ZEST_DIR, \"state\");\n\n// File paths\nexport const SESSION_FILE = join(CLAUDE_ZEST_DIR, \"session.json\"); // Auth session + workspace info\nexport const SETTINGS_FILE = join(CLAUDE_ZEST_DIR, \"settings.json\"); // User preferences\nexport const LOG_FILE = join(LOGS_DIR, \"plugin.log\");\nexport const SYNC_LOG_FILE = join(LOGS_DIR, \"sync.log\");\nexport const DAEMON_PID_FILE = join(CLAUDE_ZEST_DIR, \"daemon.pid\");\n\n// Queue files\nexport const EVENTS_QUEUE_FILE = join(QUEUE_DIR, \"events.jsonl\");\nexport const SESSIONS_QUEUE_FILE = join(QUEUE_DIR, \"chat-sessions.jsonl\");\nexport const MESSAGES_QUEUE_FILE = join(QUEUE_DIR, \"chat-messages.jsonl\");\n\n// Platform and source identifiers\nexport const PLATFORM = \"terminal\";\nexport const SOURCE = \"claude-code\";\nexport const CLIENT_ID = \"claude-cli\";\n\n// Sync configuration\nexport const SYNC_INTERVAL_MS = 60000; // 60 seconds\nexport const MAX_RETRY_ATTEMPTS = 3;\nexport const RETRY_BACKOFF_MS = 5000;\n\n// Authentication configuration\nexport const PROACTIVE_REFRESH_THRESHOLD_MS = 5 * 60 * 1000; // Refresh tokens 5 minutes before expiration\n\n// Content size limits\nexport const MAX_DIFF_SIZE_BYTES = 10 * 1024 * 1024; // 10MB\nexport const MAX_CONTENT_PREVIEW_LENGTH = 1000; // characters\nexport const MAX_SESSION_TITLE_LENGTH = 100; // characters\nexport const MIN_SESSION_TITLE_LENGTH = 3; // characters\n\n// Session quality filters\nexport const MIN_MESSAGES_PER_SESSION = 3; // Minimum messages required to upload a session\nexport const STALE_SESSION_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\n\n// API endpoints (configured from .env at build time)\n// Values are baked into the bundle during build\nexport const WEB_APP_URL = process.env.ZEST_WEB_APP_URL || \"https://app.meetzest.com\";\nexport const SUPABASE_URL = process.env.ZEST_SUPABASE_URL || \"https://fnnlebrtmlxxjwdvngck.supabase.co\";\nexport const SUPABASE_ANON_KEY = process.env.ZEST_SUPABASE_ANON_KEY || \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZubmxlYnJ0bWx4eGp3ZHZuZ2NrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY3MzA3MjYsImV4cCI6MjA3MjMwNjcyNn0.0IE3HCY_DiyyALdewbRn1vkedwzDW27NQMQ28V6j4Dk\";\n\n// Claude project directories\nexport const CLAUDE_PROJECTS_DIR = join(homedir(), \".claude\", \"projects\");\n",
    "/**\n * Logging utilities\n *\n * Handles logging to console and file system\n */\n\nimport { appendFile, mkdir } from \"node:fs/promises\";\nimport { dirname } from \"node:path\";\nimport { LOG_FILE } from \"../config/constants.js\";\n\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nclass Logger {\n  private minLevel: LogLevel = \"info\";\n\n  private levels: Record<LogLevel, number> = {\n    debug: 0,\n    info: 1,\n    warn: 2,\n    error: 3,\n  };\n\n  setLevel(level: LogLevel): void {\n    this.minLevel = level;\n  }\n\n  private async writeToFile(message: string): Promise<void> {\n    try {\n      await mkdir(dirname(LOG_FILE), { recursive: true });\n      const timestamp = new Date().toISOString();\n      await appendFile(LOG_FILE, `[${timestamp}] ${message}\\n`, \"utf-8\");\n    } catch (error) {\n      // Silently fail - don't crash if we can't write logs\n      console.error(\"Failed to write to log file:\", error);\n    }\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    return this.levels[level] >= this.levels[this.minLevel];\n  }\n\n  debug(message: string, ...args: unknown[]): void {\n    if (this.shouldLog(\"debug\")) {\n      // Only write to file, don't clutter console\n      this.writeToFile(`DEBUG: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\n    }\n  }\n\n  info(message: string, ...args: unknown[]): void {\n    if (this.shouldLog(\"info\")) {\n      // Only write to file, don't clutter console\n      this.writeToFile(`INFO: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\n    }\n  }\n\n  warn(message: string, ...args: unknown[]): void {\n    if (this.shouldLog(\"warn\")) {\n      // Show warnings to user\n      console.warn(`[Zest:Warn] ${message}`, ...args);\n      this.writeToFile(`WARN: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\n    }\n  }\n\n  error(message: string, error?: unknown): void {\n    if (this.shouldLog(\"error\")) {\n      // Show errors to user\n      console.error(`[Zest:Error] ${message}`, error);\n      this.writeToFile(\n        `ERROR: ${message} ${error instanceof Error ? error.stack : JSON.stringify(error)}`,\n      );\n    }\n  }\n}\n\nexport const logger = new Logger();\n",
    "/**\n * Local queue management for data persistence\n *\n * Manages JSONL queue files for events, sessions, and messages\n * Provides file locking to prevent corruption during concurrent writes\n */\n\nimport { appendFile, mkdir, readFile, stat, unlink, writeFile } from \"node:fs/promises\";\nimport { dirname } from \"node:path\";\nimport {\n  EVENTS_QUEUE_FILE,\n  MESSAGES_QUEUE_FILE,\n  QUEUE_DIR,\n  SESSIONS_QUEUE_FILE,\n} from \"../config/constants.js\";\nimport type {\n  ClaudeExtractedEvent,\n  ClaudeExtractedMessage,\n  ClaudeExtractedSession,\n} from \"../types/index.js\";\nimport { logger } from \"./logger.js\";\n\n// Simple file-based locking mechanism\nconst locks = new Map<string, Promise<void>>();\n\n/**\n * Acquire a lock for a file to prevent concurrent writes\n */\nasync function withLock<T>(filePath: string, fn: () => Promise<T>): Promise<T> {\n  // Wait for existing lock if present\n  while (locks.has(filePath)) {\n    await locks.get(filePath);\n  }\n\n  // Create new lock\n  let releaseLock: () => void;\n  const lockPromise = new Promise<void>((resolve) => {\n    releaseLock = resolve;\n  });\n  locks.set(filePath, lockPromise);\n\n  try {\n    return await fn();\n  } finally {\n    // Release lock\n    locks.delete(filePath);\n    releaseLock!();\n  }\n}\n\n/**\n * Ensure directory exists, creating it if necessary\n */\nasync function ensureDirectory(dirPath: string): Promise<void> {\n  try {\n    await stat(dirPath);\n  } catch {\n    await mkdir(dirPath, { recursive: true, mode: 0o700 });\n    logger.debug(`Created directory: ${dirPath}`);\n  }\n}\n\n/**\n * Append a JSON object to a JSONL file\n */\nasync function appendToJsonl(filePath: string, data: unknown): Promise<void> {\n  await withLock(filePath, async () => {\n    // Ensure directory exists\n    await ensureDirectory(dirname(filePath));\n\n    // Append JSON line\n    const line = JSON.stringify(data) + \"\\n\";\n    await appendFile(filePath, line, \"utf8\");\n  });\n}\n\n/**\n * Read all entries from a JSONL file\n */\nasync function readJsonl<T>(filePath: string): Promise<T[]> {\n  try {\n    const content = await readFile(filePath, \"utf8\");\n    const lines = content.trim().split(\"\\n\").filter(Boolean);\n\n    const results: T[] = [];\n    for (let i = 0; i < lines.length; i++) {\n      try {\n        results.push(JSON.parse(lines[i]));\n      } catch (error) {\n        logger.warn(`Failed to parse line ${i + 1} in ${filePath}:`, error);\n        // Continue processing other lines\n      }\n    }\n\n    return results;\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\n      // File doesn't exist yet, return empty array\n      return [];\n    }\n    throw error;\n  }\n}\n\n/**\n * Count lines in a JSONL file\n */\nasync function countLines(filePath: string): Promise<number> {\n  try {\n    const content = await readFile(filePath, \"utf8\");\n    const lines = content.trim().split(\"\\n\").filter(Boolean);\n    return lines.length;\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\n      return 0;\n    }\n    throw error;\n  }\n}\n\n/**\n * Delete a file (clear queue)\n */\nasync function deleteFile(filePath: string): Promise<void> {\n  try {\n    await unlink(filePath);\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\n      // File doesn't exist, nothing to delete\n      return;\n    }\n    throw error;\n  }\n}\n\n// ============================================================================\n// Public API\n// ============================================================================\n\n/**\n * Enqueue a code digest event extracted from Claude Code CLI\n */\nexport async function enqueueEvent(event: ClaudeExtractedEvent): Promise<void> {\n  try {\n    await appendToJsonl(EVENTS_QUEUE_FILE, event);\n    logger.debug(\"Enqueued event\", { eventId: event.id, documentUri: event.document_uri });\n  } catch (error) {\n    logger.error(\"Failed to enqueue event:\", error);\n    throw error;\n  }\n}\n\n/**\n * Enqueue a chat session extracted from Claude Code CLI\n */\nexport async function enqueueChatSession(session: ClaudeExtractedSession): Promise<void> {\n  try {\n    await appendToJsonl(SESSIONS_QUEUE_FILE, session);\n    logger.debug(\"Enqueued session\", { sessionId: session.id });\n  } catch (error) {\n    logger.error(\"Failed to enqueue session:\", error);\n    throw error;\n  }\n}\n\n/**\n * Enqueue a chat message extracted from Claude Code CLI\n */\nexport async function enqueueChatMessage(message: ClaudeExtractedMessage): Promise<void> {\n  try {\n    await appendToJsonl(MESSAGES_QUEUE_FILE, message);\n    logger.debug(\"Enqueued message\", {\n      sessionId: message.session_id,\n      messageIndex: message.message_index,\n    });\n  } catch (error) {\n    logger.error(\"Failed to enqueue message:\", error);\n    throw error;\n  }\n}\n\n/**\n * Read all entries from a queue file\n */\nexport async function readQueue<T>(queueFile: string): Promise<T[]> {\n  try {\n    return await readJsonl<T>(queueFile);\n  } catch (error) {\n    logger.error(`Failed to read queue file ${queueFile}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Write entries to a queue file (overwrites existing content)\n */\nexport async function writeQueue<T>(queueFile: string, items: T[]): Promise<void> {\n  try {\n    await withLock(queueFile, async () => {\n      await ensureDirectory(dirname(queueFile));\n\n      // Write all items as JSONL\n      const content =\n        items.map((item) => JSON.stringify(item)).join(\"\\n\") + (items.length > 0 ? \"\\n\" : \"\");\n      await writeFile(queueFile, content, \"utf8\");\n\n      logger.debug(`Wrote ${items.length} items to queue file: ${queueFile}`);\n    });\n  } catch (error) {\n    logger.error(`Failed to write queue file ${queueFile}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Atomically update queue files with a transform function\n * Ensures no race condition between read and write\n *\n * The entire read-modify-write cycle happens inside a lock\n */\nexport async function atomicUpdateQueue<T>(\n  queueFile: string,\n  transform: (currentItems: T[]) => T[],\n): Promise<void> {\n  try {\n    await withLock(queueFile, async () => {\n      // Read current state (inside lock)\n      const currentItems = await readJsonl<T>(queueFile);\n\n      // Apply transformation\n      const newItems = transform(currentItems);\n\n      // Write back (still inside lock)\n      await ensureDirectory(dirname(queueFile));\n      const content =\n        newItems.map((item) => JSON.stringify(item)).join(\"\\n\") + (newItems.length > 0 ? \"\\n\" : \"\");\n      await writeFile(queueFile, content, \"utf8\");\n\n      logger.debug(\n        `Atomically updated queue file: ${queueFile} (${currentItems.length} → ${newItems.length} items)`,\n      );\n    });\n  } catch (error) {\n    logger.error(`Failed to atomically update queue file ${queueFile}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Clear a queue file (delete it)\n */\nexport async function clearQueue(queueFile: string): Promise<void> {\n  try {\n    await withLock(queueFile, async () => {\n      await deleteFile(queueFile);\n      logger.debug(`Cleared queue file: ${queueFile}`);\n    });\n  } catch (error) {\n    logger.error(`Failed to clear queue file ${queueFile}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Get statistics about queued items\n */\nexport async function getQueueStats(): Promise<{\n  events: number;\n  sessions: number;\n  messages: number;\n}> {\n  try {\n    const [events, sessions, messages] = await Promise.all([\n      countLines(EVENTS_QUEUE_FILE),\n      countLines(SESSIONS_QUEUE_FILE),\n      countLines(MESSAGES_QUEUE_FILE),\n    ]);\n\n    return { events, sessions, messages };\n  } catch (error) {\n    logger.error(\"Failed to get queue stats:\", error);\n    return { events: 0, sessions: 0, messages: 0 };\n  }\n}\n\n/**\n * Ensure queue directory exists (call on initialization)\n */\nexport async function initializeQueue(): Promise<void> {\n  try {\n    await ensureDirectory(QUEUE_DIR);\n    logger.debug(\"Queue directory initialized\");\n  } catch (error) {\n    logger.error(\"Failed to initialize queue directory:\", error);\n    throw error;\n  }\n}\n",
    "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n",
    "import REGEX from './regex.js';\nfunction validate(uuid) {\n    return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;\n",
    "import validate from './validate.js';\nfunction parse(uuid) {\n    if (!validate(uuid)) {\n        throw TypeError('Invalid UUID');\n    }\n    let v;\n    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff, (v / 0x100000000) & 0xff, (v >>> 24) & 0xff, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff);\n}\nexport default parse;\n",
    "import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n",
    "import parse from './parse.js';\nimport { unsafeStringify } from './stringify.js';\nexport function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    const bytes = new Uint8Array(str.length);\n    for (let i = 0; i < str.length; ++i) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(version, hash, value, namespace, buf, offset) {\n    const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;\n    const namespaceBytes = typeof namespace === 'string' ? parse(namespace) : namespace;\n    if (typeof namespace === 'string') {\n        namespace = parse(namespace);\n    }\n    if (namespace?.length !== 16) {\n        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n    let bytes = new Uint8Array(16 + valueBytes.length);\n    bytes.set(namespaceBytes);\n    bytes.set(valueBytes, namespaceBytes.length);\n    bytes = hash(bytes);\n    bytes[6] = (bytes[6] & 0x0f) | version;\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = bytes[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(bytes);\n}\n",
    "import { createHash } from 'crypto';\nfunction sha1(bytes) {\n    if (Array.isArray(bytes)) {\n        bytes = Buffer.from(bytes);\n    }\n    else if (typeof bytes === 'string') {\n        bytes = Buffer.from(bytes, 'utf8');\n    }\n    return createHash('sha1').update(bytes).digest();\n}\nexport default sha1;\n",
    "import sha1 from './sha1.js';\nimport v35, { DNS, URL } from './v35.js';\nexport { DNS, URL } from './v35.js';\nfunction v5(value, namespace, buf, offset) {\n    return v35(0x50, sha1, value, namespace, buf, offset);\n}\nv5.DNS = DNS;\nv5.URL = URL;\nexport default v5;\n",
    "/**\n * UUID conversion utilities\n *\n * Converts agent IDs (like \"agent-a4a6215\") to deterministic UUIDs\n * using UUID v5 (name-based UUID) to ensure the same agent ID always\n * generates the same UUID.\n */\n\nimport { v5 as uuidv5 } from \"uuid\";\n\n/**\n * Namespace UUID for generating deterministic UUIDs from agent IDs.\n * This is a fixed UUID that ensures consistent UUID generation.\n * Using a fixed namespace ensures that the same agent ID always\n * generates the same UUID across different runs.\n */\nconst AGENT_ID_NAMESPACE = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\";\n\n/**\n * Converts an agent ID (e.g., \"agent-a4a6215\") to a deterministic UUID.\n * The same agent ID will always generate the same UUID.\n *\n * @param agentId - The agent ID string (e.g., \"agent-a4a6215\")\n * @returns A UUID string\n */\nexport function agentIdToUuid(agentId: string): string {\n  return uuidv5(agentId, AGENT_ID_NAMESPACE);\n}\n\n/**\n * Checks if a string is already a valid UUID format.\n *\n * @param str - The string to check\n * @returns True if the string is a valid UUID format\n */\nexport function isUuid(str: string): boolean {\n  const uuidRegex =\n    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n  return uuidRegex.test(str);\n}\n\n/**\n * Converts an agent ID to UUID if it's not already a UUID.\n * If the input is already a valid UUID, returns it unchanged.\n *\n * @param id - The ID to convert (agent ID or UUID)\n * @returns A UUID string\n */\nexport function ensureUuid(id: string): string {\n  if (isUuid(id)) {\n    return id;\n  }\n  return agentIdToUuid(id);\n}\n",
    "/**\n * Events uploader\n *\n * Uploads code digest events from queue to Supabase\n */\n\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport type { Database } from \"@zest/types/database.types\";\nimport { getValidSession } from \"../auth/session-manager.js\";\nimport { EVENTS_QUEUE_FILE, PLATFORM, SOURCE } from \"../config/constants.js\";\nimport type { ClaudeExtractedEvent, CodeDigestEventInsert } from \"../types/index.js\";\nimport { logger } from \"../utils/logger.js\";\nimport { clearQueue, readQueue } from \"../utils/queue-manager.js\";\nimport { ensureUuid } from \"../utils/uuid-converter.js\";\n\n/**\n * Deduplicate events by ID, keeping the most recent version\n */\nfunction deduplicateEvents(events: ClaudeExtractedEvent[]): ClaudeExtractedEvent[] {\n  const eventMap = new Map<string, ClaudeExtractedEvent>();\n\n  for (const event of events) {\n    if (!event.id) continue;\n\n    const existing = eventMap.get(event.id);\n    if (!existing) {\n      eventMap.set(event.id, event);\n      continue;\n    }\n\n    // Keep the event with the most recent timestamp\n    const existingTime = existing.timestamp ? new Date(existing.timestamp).getTime() : 0;\n    const currentTime = event.timestamp ? new Date(event.timestamp).getTime() : 0;\n\n    if (currentTime >= existingTime) {\n      eventMap.set(event.id, event);\n    }\n  }\n\n  return Array.from(eventMap.values());\n}\n\n/**\n * Upload all queued code digest events to Supabase\n */\nexport async function uploadEvents(\n  supabase: SupabaseClient<Database>,\n): Promise<{ success: boolean; uploaded: number }> {\n  try {\n    const session = await getValidSession();\n    if (!session) {\n      logger.debug(\"Not authenticated, skipping events upload\");\n      return { success: false, uploaded: 0 };\n    }\n\n    // Read queued events\n    const queuedEvents = await readQueue<ClaudeExtractedEvent>(EVENTS_QUEUE_FILE);\n\n    if (queuedEvents.length === 0) {\n      logger.debug(\"No events to upload\");\n      return { success: true, uploaded: 0 };\n    }\n\n    // Deduplicate events (queue might contain duplicate entries from multiple extractions)\n    const uniqueEvents = deduplicateEvents(queuedEvents);\n\n    if (uniqueEvents.length < queuedEvents.length) {\n      logger.info(\n        `Deduplicated events: ${queuedEvents.length} → ${uniqueEvents.length} (removed ${queuedEvents.length - uniqueEvents.length} duplicates)`,\n      );\n    }\n\n    logger.info(`Uploading ${uniqueEvents.length} code digest events`);\n\n    // Transform extracted data to full insert data\n    const eventsToUpload: CodeDigestEventInsert[] = uniqueEvents.map((e) => ({\n      ...e,\n      session_id: e.session_id ? ensureUuid(e.session_id) : e.session_id,\n      event_type: \"file.changed\",\n      user_id: session.userId,\n      platform: PLATFORM,\n      source: SOURCE,\n      // Also convert session_id in payload if it exists\n      payload: e.payload && typeof e.payload === \"object\" && \"session_id\" in e.payload\n        ? {\n            ...e.payload,\n            session_id: typeof e.payload.session_id === \"string\"\n              ? ensureUuid(e.payload.session_id)\n              : e.payload.session_id,\n          }\n        : e.payload,\n    }));\n\n    // Upload events in batches\n    const batchSize = 100;\n    let uploadedCount = 0;\n\n    for (let i = 0; i < eventsToUpload.length; i += batchSize) {\n      const batch = eventsToUpload.slice(i, i + batchSize);\n\n      const { error } = await supabase\n        .from(\"code_digest_events\")\n        .upsert(batch, { onConflict: \"id\" });\n\n      if (error) {\n        logger.error(`Failed to upload events batch ${i / batchSize + 1}`, error);\n        return { success: false, uploaded: uploadedCount };\n      }\n\n      uploadedCount += batch.length;\n      logger.debug(`✓ Uploaded batch ${i / batchSize + 1} (${batch.length} events)`);\n    }\n\n    // Clear queue on success\n    await clearQueue(EVENTS_QUEUE_FILE);\n\n    logger.info(`✓ Events upload completed: ${uploadedCount} events`);\n    return { success: true, uploaded: uploadedCount };\n  } catch (error) {\n    logger.error(\"Failed to upload events\", error);\n    return { success: false, uploaded: 0 };\n  }\n}\n\n/**\n * Upload events with retry logic\n */\nexport async function uploadEventsWithRetry(\n  supabase: SupabaseClient<Database>,\n  maxRetries = 3,\n  backoffMs = 5000,\n): Promise<{ success: boolean; uploaded: number }> {\n  let lastError: Error | null = null;\n\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      const result = await uploadEvents(supabase);\n      if (result.success) {\n        return result;\n      }\n\n      // If not successful but no exception thrown, don't retry (likely auth issue)\n      return result;\n    } catch (error) {\n      lastError = error as Error;\n      logger.warn(`Events upload attempt ${attempt}/${maxRetries} failed: ${lastError.message}`);\n\n      if (attempt < maxRetries) {\n        const delay = backoffMs * attempt; // Exponential backoff\n        logger.debug(`Retrying in ${delay}ms...`);\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n    }\n  }\n\n  logger.error(`Events upload failed after ${maxRetries} attempts`, lastError);\n  return { success: false, uploaded: 0 };\n}\n"
  ],
  "mappings": "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",
  "debugId": "D45A9E2B834A6E4664756E2164756E21",
  "names": []
}