{
  "version": 3,
  "sources": ["../../../packages/utils/dist/language-utils.js", "../../../packages/utils/dist/index.js", "../src/utils/daemon-manager.ts", "../src/config/constants.ts", "../src/utils/logger.ts", "../src/utils/extraction-helpers.ts", "../src/auth/session-manager.ts", "../src/extractors/message-parser.ts", "../src/extractors/extraction-utils.ts", "../../../node_modules/diff/libesm/diff/base.js", "../../../node_modules/diff/libesm/diff/character.js", "../../../node_modules/diff/libesm/util/string.js", "../../../node_modules/diff/libesm/diff/word.js", "../../../node_modules/diff/libesm/diff/line.js", "../../../node_modules/diff/libesm/diff/sentence.js", "../../../node_modules/diff/libesm/diff/css.js", "../../../node_modules/diff/libesm/diff/json.js", "../../../node_modules/diff/libesm/diff/array.js", "../../../node_modules/diff/libesm/patch/create.js", "../src/utils/diff-utils.ts", "../src/utils/queue-manager.ts", "../src/utils/state-manager.ts", "../src/hooks/session-handler-cli.ts"],
  "sourcesContent": [
    "\"use strict\";\n/**\n * Language detection utilities\n *\n * Maps file extensions to language IDs\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getLanguageFromPath = getLanguageFromPath;\nexports.detectLanguageId = detectLanguageId;\n/**\n * Comprehensive language map for file extension to language ID mapping\n */\nvar languageMap = {\n    // TypeScript / JavaScript\n    ts: \"typescript\",\n    tsx: \"typescriptreact\",\n    js: \"javascript\",\n    jsx: \"javascriptreact\",\n    mjs: \"javascript\",\n    cjs: \"javascript\",\n    // Python\n    py: \"python\",\n    pyi: \"python\",\n    pyw: \"python\",\n    // Rust\n    rs: \"rust\",\n    // Go\n    go: \"go\",\n    // Java / JVM\n    java: \"java\",\n    kt: \"kotlin\",\n    kts: \"kotlin\",\n    scala: \"scala\",\n    groovy: \"groovy\",\n    gradle: \"groovy\",\n    // C family\n    c: \"c\",\n    h: \"c\",\n    cpp: \"cpp\",\n    cc: \"cpp\",\n    cxx: \"cpp\",\n    hpp: \"cpp\",\n    hxx: \"hpp\",\n    // C#\n    cs: \"csharp\",\n    // Ruby\n    rb: \"ruby\",\n    // PHP\n    php: \"php\",\n    // Swift\n    swift: \"swift\",\n    // Objective-C\n    m: \"objective-c\",\n    mm: \"objective-cpp\",\n    // Web frameworks\n    vue: \"vue\",\n    svelte: \"svelte\",\n    astro: \"astro\",\n    // Dart / Flutter\n    dart: \"dart\",\n    // Elixir\n    ex: \"elixir\",\n    exs: \"elixir\",\n    // Clojure\n    clj: \"clojure\",\n    cljs: \"clojure\",\n    edn: \"clojure\",\n    // Haskell\n    hs: \"haskell\",\n    lhs: \"haskell\",\n    // Lua\n    lua: \"lua\",\n    // Erlang\n    erl: \"erlang\",\n    hrl: \"erlang\",\n    // Perl\n    pl: \"perl\",\n    pm: \"perl\",\n    // CoffeeScript\n    coffee: \"coffeescript\",\n    // Shell\n    sh: \"shellscript\",\n    bash: \"shellscript\",\n    zsh: \"shellscript\",\n    fish: \"shellscript\",\n    // PowerShell\n    ps1: \"powershell\",\n    psm1: \"powershell\",\n    // Batch\n    bat: \"bat\",\n    cmd: \"bat\",\n    // Markup / Config\n    md: \"markdown\",\n    mdx: \"mdx\",\n    json: \"json\",\n    jsonc: \"jsonc\",\n    yaml: \"yaml\",\n    yml: \"yaml\",\n    toml: \"toml\",\n    xml: \"xml\",\n    html: \"html\",\n    htm: \"html\",\n    ini: \"ini\",\n    properties: \"properties\",\n    // Styles\n    css: \"css\",\n    scss: \"scss\",\n    sass: \"sass\",\n    less: \"less\",\n    // SQL\n    sql: \"sql\",\n    // Other\n    graphql: \"graphql\",\n    gql: \"graphql\",\n    proto: \"protobuf\",\n    dockerfile: \"dockerfile\",\n    tf: \"terraform\",\n    r: \"r\",\n};\n/**\n * Get language ID from file path based on extension.\n * Supports both formats: with or without leading dot in extension.\n *\n * @param filePath - The file path to detect language from\n * @returns The language ID (e.g., \"typescript\", \"python\") or \"plaintext\" if unknown\n *\n * @example\n * ```ts\n * getLanguageFromPath(\"src/index.ts\") // => \"typescript\"\n * getLanguageFromPath(\"script.py\") // => \"python\"\n * getLanguageFromPath(\"README.md\") // => \"markdown\"\n * ```\n */\nfunction getLanguageFromPath(filePath) {\n    var _a;\n    // Extract extension without the dot\n    var ext = (_a = filePath.split(\".\").pop()) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n    return languageMap[ext || \"\"] || \"plaintext\";\n}\n/**\n * Alias for getLanguageFromPath for backward compatibility\n * @deprecated Use getLanguageFromPath instead\n */\nfunction detectLanguageId(filePath) {\n    return getLanguageFromPath(filePath);\n}\n//# sourceMappingURL=language-utils.js.map",
    "\"use strict\";\n/**\n * @zest/utils\n *\n * Shared utility functions for Zest applications\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getLanguageFromPath = exports.detectLanguageId = void 0;\nvar language_utils_js_1 = require(\"./language-utils.js\");\nObject.defineProperty(exports, \"detectLanguageId\", { enumerable: true, get: function () { return language_utils_js_1.detectLanguageId; } });\nObject.defineProperty(exports, \"getLanguageFromPath\", { enumerable: true, get: function () { return language_utils_js_1.getLanguageFromPath; } });\n//# sourceMappingURL=index.js.map",
    "/**\n * Daemon lifecycle management\n *\n * Handles PID tracking, daemon startup, and process detection\n */\n\nimport { spawn } from \"node:child_process\";\nimport { readFile, unlink, writeFile } from \"node:fs/promises\";\nimport { dirname, join } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport { DAEMON_PID_FILE } from \"../config/constants.js\";\nimport { logger } from \"./logger.js\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n/**\n * Start the sync daemon as a detached background process\n */\nexport async function startDaemon(): Promise<boolean> {\n  try {\n    logger.info(\"Starting sync daemon...\");\n\n    // Find the daemon script path\n    const daemonScript = join(__dirname, \"..\", \"sync-daemon.js\");\n\n    // Spawn daemon as detached background process\n    const daemon = spawn(process.execPath, [daemonScript], {\n      detached: true, // Run independently\n      stdio: \"ignore\", // Don't capture output\n      windowsHide: true, // Hide console window on Windows\n    });\n\n    // Unref so parent can exit without waiting for daemon\n    daemon.unref();\n\n    logger.info(`✓ Daemon started (PID: ${daemon.pid})`);\n\n    // Daemon writes its own PID file when it starts\n    // Wait a moment to ensure it's written\n    await new Promise((resolve) => setTimeout(resolve, 100));\n\n    return true;\n  } catch (error) {\n    logger.error(\"Failed to start daemon:\", error);\n    return false;\n  }\n}\n\n/**\n * Restart daemon - kills existing daemon and starts a new one\n * Useful for picking up plugin updates\n */\nexport async function restartDaemon(): Promise<boolean> {\n  try {\n    logger.info(\"Restarting daemon...\");\n\n    // Kill existing daemon if running\n    const pid = await getDaemonPid();\n    if (pid) {\n      logger.info(`Stopping existing daemon (PID: ${pid})`);\n      try {\n        process.kill(pid, \"SIGTERM\");\n        // Wait a moment for graceful shutdown\n        await new Promise((resolve) => setTimeout(resolve, 500));\n      } catch (error) {\n        logger.warn(`Failed to stop daemon PID ${pid}:`, error);\n      }\n      await cleanupPidFile();\n    }\n\n    // Start new daemon\n    const started = await startDaemon();\n    if (started) {\n      logger.info(\"✓ Daemon restarted successfully\");\n    }\n    return started;\n  } catch (error) {\n    logger.error(\"Failed to restart daemon:\", error);\n    return false;\n  }\n}\n\n/**\n * Clean up stale PID file\n */\nasync function cleanupPidFile(): Promise<void> {\n  try {\n    await unlink(DAEMON_PID_FILE);\n  } catch {\n    // Ignore errors - file might not exist\n  }\n}\n\n/**\n * Write PID to daemon.pid file\n * Called by the daemon itself when it starts\n */\nexport async function writePidFile(pid: number): Promise<void> {\n  try {\n    await writeFile(DAEMON_PID_FILE, pid.toString(), \"utf-8\");\n    logger.debug(`Wrote PID ${pid} to daemon.pid`);\n  } catch (error) {\n    logger.error(\"Failed to write PID file:\", error);\n  }\n}\n\n/**\n * Get daemon PID (if running)\n */\nexport async function getDaemonPid(): Promise<number | null> {\n  try {\n    const pidData = await readFile(DAEMON_PID_FILE, \"utf-8\");\n    const pid = Number.parseInt(pidData.trim(), 10);\n\n    if (Number.isNaN(pid)) {\n      return null;\n    }\n\n    // Verify process exists\n    try {\n      process.kill(pid, 0);\n      return pid;\n    } catch {\n      return null;\n    }\n  } catch {\n    return null;\n  }\n}\n",
    "/**\n * Application constants and configuration values\n */\n\nimport { homedir } from \"node:os\";\nimport { join } from \"node:path\";\n\n// Base directories\nexport const CLAUDE_ZEST_DIR = join(homedir(), \".claude-zest\");\nexport const QUEUE_DIR = join(CLAUDE_ZEST_DIR, \"queue\");\nexport const LOGS_DIR = join(CLAUDE_ZEST_DIR, \"logs\");\nexport const STATE_DIR = join(CLAUDE_ZEST_DIR, \"state\");\n\n// File paths\nexport const SESSION_FILE = join(CLAUDE_ZEST_DIR, \"session.json\"); // Auth session + workspace info\nexport const SETTINGS_FILE = join(CLAUDE_ZEST_DIR, \"settings.json\"); // User preferences\nexport const LOG_FILE = join(LOGS_DIR, \"plugin.log\");\nexport const SYNC_LOG_FILE = join(LOGS_DIR, \"sync.log\");\nexport const DAEMON_PID_FILE = join(CLAUDE_ZEST_DIR, \"daemon.pid\");\n\n// Queue files\nexport const EVENTS_QUEUE_FILE = join(QUEUE_DIR, \"events.jsonl\");\nexport const SESSIONS_QUEUE_FILE = join(QUEUE_DIR, \"chat-sessions.jsonl\");\nexport const MESSAGES_QUEUE_FILE = join(QUEUE_DIR, \"chat-messages.jsonl\");\n\n// Platform and source identifiers\nexport const PLATFORM = \"terminal\";\nexport const SOURCE = \"claude-code\";\nexport const CLIENT_ID = \"claude-cli\";\n\n// Sync configuration\nexport const SYNC_INTERVAL_MS = 60000; // 60 seconds\nexport const MAX_RETRY_ATTEMPTS = 3;\nexport const RETRY_BACKOFF_MS = 5000;\n\n// Authentication configuration\nexport const PROACTIVE_REFRESH_THRESHOLD_MS = 5 * 60 * 1000; // Refresh tokens 5 minutes before expiration\n\n// Content size limits\nexport const MAX_DIFF_SIZE_BYTES = 10 * 1024 * 1024; // 10MB\nexport const MAX_CONTENT_PREVIEW_LENGTH = 1000; // characters\nexport const MAX_SESSION_TITLE_LENGTH = 100; // characters\nexport const MIN_SESSION_TITLE_LENGTH = 3; // characters\n\n// Session quality filters\nexport const MIN_MESSAGES_PER_SESSION = 3; // Minimum messages required to upload a session\nexport const STALE_SESSION_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\n\n// API endpoints (configured from .env at build time)\n// Values are baked into the bundle during build\nexport const WEB_APP_URL = process.env.ZEST_WEB_APP_URL || \"http://localhost:3000\";\nexport const SUPABASE_URL = process.env.ZEST_SUPABASE_URL || \"\";\nexport const SUPABASE_ANON_KEY = process.env.ZEST_SUPABASE_ANON_KEY || \"\";\n\n// Claude project directories\nexport const CLAUDE_PROJECTS_DIR = join(homedir(), \".claude\", \"projects\");\n",
    "/**\n * Logging utilities\n *\n * Handles logging to console and file system\n */\n\nimport { appendFile, mkdir } from \"node:fs/promises\";\nimport { dirname } from \"node:path\";\nimport { LOG_FILE } from \"../config/constants.js\";\n\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nclass Logger {\n  private minLevel: LogLevel = \"info\";\n\n  private levels: Record<LogLevel, number> = {\n    debug: 0,\n    info: 1,\n    warn: 2,\n    error: 3,\n  };\n\n  setLevel(level: LogLevel): void {\n    this.minLevel = level;\n  }\n\n  private async writeToFile(message: string): Promise<void> {\n    try {\n      await mkdir(dirname(LOG_FILE), { recursive: true });\n      const timestamp = new Date().toISOString();\n      await appendFile(LOG_FILE, `[${timestamp}] ${message}\\n`, \"utf-8\");\n    } catch (error) {\n      // Silently fail - don't crash if we can't write logs\n      console.error(\"Failed to write to log file:\", error);\n    }\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    return this.levels[level] >= this.levels[this.minLevel];\n  }\n\n  debug(message: string, ...args: unknown[]): void {\n    if (this.shouldLog(\"debug\")) {\n      // Only write to file, don't clutter console\n      this.writeToFile(`DEBUG: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\n    }\n  }\n\n  info(message: string, ...args: unknown[]): void {\n    if (this.shouldLog(\"info\")) {\n      // Only write to file, don't clutter console\n      this.writeToFile(`INFO: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\n    }\n  }\n\n  warn(message: string, ...args: unknown[]): void {\n    if (this.shouldLog(\"warn\")) {\n      // Show warnings to user\n      console.warn(`[Zest:Warn] ${message}`, ...args);\n      this.writeToFile(`WARN: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\n    }\n  }\n\n  error(message: string, error?: unknown): void {\n    if (this.shouldLog(\"error\")) {\n      // Show errors to user\n      console.error(`[Zest:Error] ${message}`, error);\n      this.writeToFile(\n        `ERROR: ${message} ${error instanceof Error ? error.stack : JSON.stringify(error)}`,\n      );\n    }\n  }\n}\n\nexport const logger = new Logger();\n",
    "/**\n * Shared extraction helper functions for hook handlers\n *\n * Provides reusable logic for finding sessions, extracting data, and queueing events\n */\n\nimport { randomUUID } from \"node:crypto\";\nimport { stat } from \"node:fs/promises\";\nimport { basename, join } from \"node:path\";\nimport { getLanguageFromPath } from \"@zest/utils\";\nimport { getValidSession } from \"../auth/session-manager.js\";\nimport { CLAUDE_PROJECTS_DIR } from \"../config/constants.js\";\nimport { extractNewMessagesFromFile } from \"../extractors/message-parser.js\";\nimport type { ToolUse } from \"../types/extractors.js\";\nimport type {\n  ClaudeExtractedEvent,\n  ClaudeExtractedMessage,\n  ClaudeExtractedSession,\n} from \"../types/index.js\";\nimport { logger } from \"./logger.js\";\nimport { enqueueChatMessage, enqueueChatSession, enqueueEvent } from \"./queue-manager.js\";\nimport { readSessionState, updateLastReadLine } from \"./state-manager.js\";\n\n/**\n * File stats from fs.stat()\n */\ninterface FileStats {\n  birthtime: Date;\n  mtime: Date;\n  mtimeMs: number;\n  size: number;\n}\n\n/**\n * Find the most recent conversation file for a project\n */\nexport async function findConversationFile(\n  projectDir: string,\n): Promise<{ conversationFile: string; sessionId: string; fileStats: FileStats } | null> {\n  try {\n    // Convert CWD to Claude's directory naming convention\n    const claudeDirName = projectDir.replace(/\\//g, \"-\");\n    const projectPath = join(CLAUDE_PROJECTS_DIR, claudeDirName);\n\n    logger.debug(`Looking for project directory: ${projectPath}`);\n\n    // Check if directory exists\n    try {\n      await stat(projectPath);\n    } catch {\n      logger.warn(`Project directory not found: ${projectPath}`);\n      return null;\n    }\n\n    // Find the most recent JSONL file\n    const { readdir } = await import(\"node:fs/promises\");\n    const entries = await readdir(projectPath);\n    const jsonlFiles = entries.filter((f) => f.endsWith(\".jsonl\"));\n\n    if (jsonlFiles.length === 0) {\n      logger.warn(`No session files found in ${projectPath}`);\n      return null;\n    }\n\n    // Get the most recently modified .jsonl file\n    let mostRecentFile = jsonlFiles[0];\n    let mostRecentTime = 0;\n\n    for (const file of jsonlFiles) {\n      const filePath = join(projectPath, file);\n      const stats = await stat(filePath);\n      if (stats.mtimeMs > mostRecentTime) {\n        mostRecentTime = stats.mtimeMs;\n        mostRecentFile = file;\n      }\n    }\n\n    const conversationFile = join(projectPath, mostRecentFile);\n    const sessionId = basename(mostRecentFile, \".jsonl\");\n    const fileStats = await stat(conversationFile);\n\n    return { conversationFile, sessionId, fileStats };\n  } catch (error) {\n    logger.error(\"Failed to find conversation file:\", error);\n    return null;\n  }\n}\n\n/**\n * Extract new session data (messages and tool uses) from conversation file\n * Single Responsibility: Extraction only\n */\nexport async function extractNewSessionData(\n  conversationFile: string,\n  sessionId: string,\n): Promise<{\n  messages: ClaudeExtractedMessage[];\n  toolUses: ToolUse[];\n  newLastReadLine: number;\n  lastMessageIndex: number;\n  isNewSession: boolean;\n  hasNewData: boolean;\n}> {\n  // Read extraction state\n  const state = await readSessionState(sessionId);\n  const lastReadLine = state?.lastReadLine || 0;\n  const lastMessageIndex = state?.lastMessageIndex ?? -1; // Start at -1 so first message is 0\n  const isNewSession = !state;\n\n  logger.info(\n    `Extraction state: lastReadLine=${lastReadLine}, lastMessageIndex=${lastMessageIndex} (${isNewSession ? \"new session\" : \"existing session\"})`,\n  );\n\n  // Extract only new messages/tool uses\n  const { messages, toolUses, newLastReadLine } = await extractNewMessagesFromFile(\n    conversationFile,\n    sessionId,\n    lastReadLine,\n  );\n\n  // Assign sequential message_index to extracted messages\n  let nextMessageIndex = lastMessageIndex + 1;\n  for (const message of messages) {\n    message.message_index = nextMessageIndex++;\n  }\n\n  logger.info(\n    `Extraction results: ${messages.length} messages (indices ${lastMessageIndex + 1}-${nextMessageIndex - 1}), ${toolUses.length} tool uses, ${newLastReadLine - lastReadLine} new lines`,\n  );\n\n  const hasNewData = messages.length > 0 || toolUses.length > 0;\n\n  if (!hasNewData) {\n    logger.info(\"No new data to process\");\n  }\n\n  return {\n    messages,\n    toolUses,\n    newLastReadLine,\n    lastMessageIndex: nextMessageIndex - 1, // Last assigned index\n    isNewSession,\n    hasNewData,\n  };\n}\n\n/**\n * Queue extracted session data (session info, messages, and events)\n * Single Responsibility: Queuing only\n */\nexport async function queueSessionData(\n  sessionId: string,\n  messages: ClaudeExtractedMessage[],\n  toolUses: ToolUse[],\n  fileStats: FileStats,\n  projectDir: string,\n  conversationFile: string,\n  newLastReadLine: number,\n  lastMessageIndex: number,\n  isNewSession: boolean,\n): Promise<{ messagesQueued: number; eventsQueued: number }> {\n  // Queue the session info (first time only)\n  if (isNewSession) {\n    const session: ClaudeExtractedSession = {\n      id: sessionId,\n      title: messages.length > 0 ? messages[0].content.substring(0, 100) : `Session ${sessionId}`,\n      created_at: fileStats.birthtime.toISOString(),\n    };\n    await enqueueChatSession(session);\n    logger.info(`Queued new session: ${session.id}`);\n  }\n\n  // Queue all messages (minimal extracted data)\n  for (const message of messages) {\n    const extractedMessage: ClaudeExtractedMessage = {\n      id: message.id,\n      session_id: message.session_id,\n      message_index: message.message_index,\n      role: message.role,\n      content: message.content,\n      created_at: message.created_at,\n    };\n    await enqueueChatMessage(extractedMessage);\n  }\n  if (messages.length > 0) {\n    logger.info(`Queued ${messages.length} messages`);\n  }\n\n  // Convert tool uses to code digest events with filtering\n  const eventsQueued = await queueToolUseEvents(toolUses, sessionId, projectDir);\n\n  // Update state with new line number and last message index\n  await updateLastReadLine(sessionId, conversationFile, newLastReadLine, lastMessageIndex);\n  logger.info(\n    `Updated extraction state: lastReadLine=${newLastReadLine}, lastMessageIndex=${lastMessageIndex}`,\n  );\n\n  return { messagesQueued: messages.length, eventsQueued };\n}\n\n/**\n * Queue tool use events (with filtering for file edits with diffs)\n */\nasync function queueToolUseEvents(\n  toolUses: ToolUse[],\n  sessionId: string,\n  projectDir: string,\n): Promise<number> {\n  // FILTER: Only include file edits with actual code diffs (exclude Read operations and edits without diffs)\n  // Get workspace ID from user's session\n  const session = await getValidSession();\n  const workspaceId = session?.workspaceId || null;\n\n  let queuedEventCount = 0;\n\n  for (const toolUse of toolUses) {\n    // Skip if no file path\n    if (!toolUse.file_path) continue;\n\n    // Skip Read operations (we only want file edits)\n    if (toolUse.tool_name === \"Read\" || toolUse.tool_name === \"read\") {\n      continue;\n    }\n\n    // Skip edits that don't have a diff (no actual code change)\n    if (!toolUse.diff) {\n      continue;\n    }\n\n    const event: ClaudeExtractedEvent = {\n      id: randomUUID(),\n      timestamp: toolUse.timestamp,\n      document_uri: toolUse.file_path,\n      language_id: getLanguageFromPath(toolUse.file_path),\n      workspace_folder_uri: projectDir || null,\n      session_id: sessionId,\n      workspace_id: workspaceId,\n      payload: {\n        tool_name: toolUse.tool_name,\n        session_id: sessionId,\n        diff: toolUse.diff, // Already sanitized unified diff string\n      },\n    };\n\n    await enqueueEvent(event);\n    queuedEventCount++;\n  }\n\n  if (queuedEventCount > 0) {\n    logger.info(`Queued ${queuedEventCount} code change events`);\n  }\n\n  return queuedEventCount;\n}\n",
    "/**\n * Session management\n *\n * Handles session persistence, validation, and token refresh\n */\n\nimport { mkdir, readFile, unlink, writeFile } from \"node:fs/promises\";\nimport { dirname } from \"node:path\";\nimport { PROACTIVE_REFRESH_THRESHOLD_MS, SESSION_FILE, WEB_APP_URL } from \"../config/constants.js\";\nimport { logger } from \"../utils/logger.js\";\n\nexport interface AuthSession {\n  accessToken: string;\n  refreshToken: string;\n  expiresAt: number; // Access token expiration (milliseconds)\n  refreshTokenExpiresAt?: number; // Refresh token expiration (milliseconds) - optional for backward compatibility\n  userId: string;\n  email: string;\n  workspaceId?: string;\n  workspaceName?: string;\n}\n\n/**\n * Load session from file\n */\nexport async function loadSession(): Promise<AuthSession | null> {\n  try {\n    const content = await readFile(SESSION_FILE, \"utf-8\");\n    const session = JSON.parse(content) as AuthSession;\n\n    // Validate session structure\n    if (\n      !session.accessToken ||\n      !session.refreshToken ||\n      !session.expiresAt ||\n      !session.userId ||\n      !session.email\n    ) {\n      logger.warn(\"Invalid session structure, clearing session\");\n      await clearSession();\n      return null;\n    }\n\n    const now = Date.now();\n\n    // Check if refresh token is expired (only if expiration is set - many configs have refresh tokens that never expire)\n    if (session.refreshTokenExpiresAt && session.refreshTokenExpiresAt < now) {\n      logger.warn(\"Refresh token expired, user must re-authenticate\");\n      await clearSession();\n      return null;\n    }\n\n    // Check if access token is expired\n    if (session.expiresAt < now) {\n      logger.debug(\"Access token expired, attempting refresh\");\n      try {\n        return await refreshSession(session);\n      } catch (error) {\n        logger.warn(\"Failed to refresh session\", error);\n        await clearSession();\n        return null;\n      }\n    }\n\n    return session;\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\n      // File doesn't exist - not an error\n      return null;\n    }\n    logger.error(\"Failed to load session\", error);\n    return null;\n  }\n}\n\n/**\n * Save session to file with secure permissions\n */\nexport async function saveSession(session: AuthSession): Promise<void> {\n  try {\n    // Ensure directory exists\n    await mkdir(dirname(SESSION_FILE), { recursive: true, mode: 0o700 });\n\n    // Write session file\n    await writeFile(SESSION_FILE, JSON.stringify(session, null, 2), {\n      encoding: \"utf-8\",\n      mode: 0o600, // Readable/writable by owner only\n    });\n\n    logger.info(\"Session saved successfully\");\n  } catch (error) {\n    logger.error(\"Failed to save session\", error);\n    throw error;\n  }\n}\n\n/**\n * Clear session file\n */\nexport async function clearSession(): Promise<void> {\n  try {\n    await unlink(SESSION_FILE);\n    logger.info(\"Session cleared successfully\");\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\n      // File doesn't exist - not an error\n      return;\n    }\n    logger.error(\"Failed to clear session\", error);\n    throw error;\n  }\n}\n\n/**\n * Refresh an expired session using the refresh token\n */\nexport async function refreshSession(session: AuthSession): Promise<AuthSession> {\n  try {\n    logger.debug(\"Refreshing session\");\n\n    const response = await fetch(`${WEB_APP_URL}/api/auth/extension/refresh`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        refreshToken: session.refreshToken,\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Token refresh failed: ${response.status} ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as {\n      accessToken: string;\n      refreshToken: string;\n      expiresIn: number; // seconds until access token expiration\n      refreshTokenExpiresIn?: number; // seconds until refresh token expiration\n    };\n\n    // Use actual expiration from Supabase (convert seconds to milliseconds)\n    const now = Date.now();\n    const expiresAt = now + data.expiresIn * 1000;\n\n    // Calculate refresh token expiration (if provided, otherwise keep existing or undefined for \"never expires\")\n    const refreshTokenExpiresAt = data.refreshTokenExpiresIn\n      ? now + data.refreshTokenExpiresIn * 1000\n      : session.refreshTokenExpiresAt; // Keep existing or undefined (never expires)\n\n    const newSession: AuthSession = {\n      ...session,\n      accessToken: data.accessToken,\n      refreshToken: data.refreshToken,\n      expiresAt,\n      refreshTokenExpiresAt,\n    };\n\n    logger.debug(\n      `Access token will expire in ${data.expiresIn} seconds (${new Date(expiresAt).toISOString()})`,\n    );\n    if (refreshTokenExpiresAt) {\n      logger.debug(`Refresh token will expire at ${new Date(refreshTokenExpiresAt).toISOString()}`);\n    } else {\n      logger.debug(\"Refresh token does not expire\");\n    }\n\n    await saveSession(newSession);\n    logger.info(\"Session refreshed successfully\");\n\n    return newSession;\n  } catch (error) {\n    logger.error(\"Failed to refresh session\", error);\n    throw error;\n  }\n}\n\n/**\n * Check if user is currently authenticated\n */\nexport async function isAuthenticated(): Promise<boolean> {\n  const session = await loadSession();\n  return session !== null && session.expiresAt > Date.now();\n}\n\n/**\n * Get current session (refresh if needed)\n *\n * Proactively refreshes tokens 5 minutes before expiration\n */\nexport async function getValidSession(): Promise<AuthSession | null> {\n  const session = await loadSession();\n  if (!session) {\n    return null;\n  }\n\n  const now = Date.now();\n  const timeUntilExpiration = session.expiresAt - now;\n\n  // Refresh if expired or expiring soon (within 5 minutes)\n  if (timeUntilExpiration < PROACTIVE_REFRESH_THRESHOLD_MS) {\n    try {\n      logger.debug(\n        `Token ${timeUntilExpiration < 0 ? \"expired\" : `expiring in ${Math.round(timeUntilExpiration / 1000)}s`}, refreshing...`,\n      );\n      return await refreshSession(session);\n    } catch (error) {\n      logger.warn(\"Failed to refresh session\", error);\n      return null; // Can't use expired/expiring session\n    }\n  }\n\n  return session;\n}\n",
    "/**\n * Message parsing logic for Claude JSONL files\n */\n\nimport { readFile } from \"node:fs/promises\";\nimport type { ClaudeJSONLEntry, ToolUse } from \"../types/extractors.js\";\nimport type { ClaudeExtractedMessage } from \"../types/index.js\";\nimport { logger } from \"../utils/logger.js\";\nimport {\n  extractTextContent,\n  extractToolUse,\n  extractToolUseResult,\n  generateMessageId,\n  logDiff,\n} from \"./extraction-utils.js\";\n\n/**\n * Extract messages and tool uses from a conversation JSONL file (full extraction)\n */\nexport async function extractMessagesFromFile(\n  filePath: string,\n  sessionId: string,\n): Promise<{ messages: ClaudeExtractedMessage[]; toolUses: ToolUse[] }> {\n  const messages: ClaudeExtractedMessage[] = [];\n  const toolUses: ToolUse[] = [];\n\n  try {\n    const content = await readFile(filePath, \"utf-8\");\n    const lines = content.split(\"\\n\").filter((line) => line.trim());\n\n    // Extract messages without worrying about message_index\n    // (will be assigned sequentially during queuing)\n    let tempMessageCounter = 0;\n\n    for (const line of lines) {\n      try {\n        const entry: ClaudeJSONLEntry = JSON.parse(line);\n\n        // Skip entries without message field\n        if (!entry.message) continue;\n\n        const role = entry.message.role;\n        const content = entry.message.content;\n\n        // Extract user or assistant messages\n        if ((role === \"user\" || role === \"assistant\") && content) {\n          const textContent = extractTextContent(content);\n\n          if (textContent) {\n            const messageId = entry.uuid || generateMessageId(sessionId, tempMessageCounter);\n\n            messages.push({\n              id: messageId,\n              session_id: sessionId,\n              role: role,\n              content: textContent,\n              created_at: entry.timestamp || new Date().toISOString(),\n              message_index: tempMessageCounter, // Temporary - reassigned sequentially during queuing\n            });\n            tempMessageCounter++;\n          }\n        }\n\n        // Check message content array for tool uses\n        if (Array.isArray(content)) {\n          for (const contentBlock of content) {\n            if (contentBlock.type === \"tool_use\") {\n              const toolUse = extractToolUse(contentBlock, sessionId, entry.timestamp);\n              if (toolUse) {\n                toolUses.push(toolUse);\n              }\n            }\n          }\n        }\n\n        // Extract tool use results with diffs\n        if (entry.toolUseResult) {\n          const toolUseWithDiff = extractToolUseResult(entry, sessionId);\n          if (toolUseWithDiff) {\n            toolUses.push(toolUseWithDiff);\n            logDiff(toolUseWithDiff.file_path || \"\", toolUseWithDiff.diff);\n          }\n        }\n      } catch (parseError) {\n        logger.debug(`Failed to parse JSONL line: ${line.substring(0, 100)}...`, parseError);\n      }\n    }\n  } catch (error) {\n    logger.error(`Failed to read conversation file ${filePath}:`, error);\n  }\n\n  return { messages, toolUses };\n}\n\n/**\n * Extract only NEW messages and tool uses from JSONL file (incremental extraction)\n *\n * @param filePath - Path to conversation.jsonl file\n * @param sessionId - Session identifier\n * @param lastReadLine - Last line number that was read (0-indexed)\n * @returns New messages, tool uses, and updated line number\n */\nexport async function extractNewMessagesFromFile(\n  filePath: string,\n  sessionId: string,\n  lastReadLine = 0,\n): Promise<{\n  messages: ClaudeExtractedMessage[];\n  toolUses: ToolUse[];\n  newLastReadLine: number;\n  totalLines: number;\n}> {\n  const messages: ClaudeExtractedMessage[] = [];\n  const toolUses: ToolUse[] = [];\n\n  try {\n    logger.debug(`Incremental extraction for ${sessionId}: reading from line ${lastReadLine}`);\n\n    const content = await readFile(filePath, \"utf-8\");\n    const lines = content.split(\"\\n\").filter((line) => line.trim());\n    const totalLines = lines.length;\n\n    // Check if there are new lines to process\n    if (totalLines <= lastReadLine) {\n      logger.debug(`No new lines for ${sessionId}: total=${totalLines}, lastRead=${lastReadLine}`);\n      return { messages, toolUses, newLastReadLine: lastReadLine, totalLines };\n    }\n\n    // Process only new lines\n    const newLines = lines.slice(lastReadLine);\n    logger.info(\n      `Processing ${newLines.length} new lines for session ${sessionId} (lines ${lastReadLine + 1}-${totalLines})`,\n    );\n\n    // Extract messages without worrying about message_index\n    // (will be assigned sequentially during queuing)\n    let tempMessageCounter = 0;\n\n    for (let i = 0; i < newLines.length; i++) {\n      const line = newLines[i];\n      const lineNumber = lastReadLine + i;\n\n      try {\n        const entry: ClaudeJSONLEntry = JSON.parse(line);\n\n        // Skip entries without message field\n        if (!entry.message) continue;\n\n        const role = entry.message.role;\n        const content = entry.message.content;\n\n        // Extract user or assistant messages\n        if ((role === \"user\" || role === \"assistant\") && content) {\n          const textContent = extractTextContent(content);\n\n          if (textContent) {\n            const messageId = entry.uuid || generateMessageId(sessionId, tempMessageCounter);\n\n            messages.push({\n              id: messageId,\n              session_id: sessionId,\n              role: role,\n              content: textContent,\n              created_at: entry.timestamp || new Date().toISOString(),\n              message_index: tempMessageCounter, // Temporary - reassigned sequentially during queuing\n            });\n            tempMessageCounter++;\n\n            logger.debug(\n              `Extracted ${role} message at line ${lineNumber + 1}: ${textContent.substring(0, 50)}...`,\n            );\n          }\n        }\n\n        // Check message content array for tool uses\n        if (Array.isArray(content)) {\n          for (const contentBlock of content) {\n            if (contentBlock.type === \"tool_use\") {\n              const toolUse = extractToolUse(contentBlock, sessionId, entry.timestamp);\n              if (toolUse) {\n                toolUses.push(toolUse);\n                logger.debug(\n                  `Extracted tool use at line ${lineNumber + 1}: ${toolUse.tool_name} on ${toolUse.file_path}`,\n                );\n              }\n            }\n          }\n        }\n\n        // Extract tool use results with diffs\n        if (entry.toolUseResult) {\n          const toolUseWithDiff = extractToolUseResult(entry, sessionId);\n          if (toolUseWithDiff) {\n            toolUses.push(toolUseWithDiff);\n\n            logger.debug(\n              `Extracted tool result at line ${lineNumber + 1}: ${toolUseWithDiff.file_path}`,\n            );\n\n            logDiff(toolUseWithDiff.file_path || \"\", toolUseWithDiff.diff);\n          }\n        }\n      } catch (parseError) {\n        logger.debug(\n          `Failed to parse JSONL line ${lineNumber + 1}: ${line.substring(0, 100)}...`,\n          parseError,\n        );\n      }\n    }\n\n    logger.info(\n      `Incremental extraction complete: ${messages.length} messages, ${toolUses.length} tool uses`,\n    );\n\n    return {\n      messages,\n      toolUses,\n      newLastReadLine: totalLines,\n      totalLines,\n    };\n  } catch (error) {\n    logger.error(`Failed to incrementally read conversation file ${filePath}:`, error);\n    return {\n      messages,\n      toolUses,\n      newLastReadLine: lastReadLine,\n      totalLines: lastReadLine,\n    };\n  }\n}\n",
    "/**\n * Utility functions for extracting data from Claude JSONL entries\n */\n\nimport { createHash } from \"node:crypto\";\nimport {\n  MAX_CONTENT_PREVIEW_LENGTH,\n  MAX_SESSION_TITLE_LENGTH,\n  MIN_SESSION_TITLE_LENGTH,\n} from \"../config/constants.js\";\nimport type { ClaudeJSONLEntry, ContentBlock, ToolInput, ToolUse } from \"../types/extractors.js\";\nimport { sanitizeDiff } from \"../utils/diff-utils.js\";\nimport { logger } from \"../utils/logger.js\";\n\n/**\n * Extract text content from message content field\n */\nexport function extractTextContent(content: string | ContentBlock[]): string {\n  if (typeof content === \"string\") {\n    return content;\n  }\n\n  if (Array.isArray(content)) {\n    const textBlocks = content\n      .filter((block) => block.type === \"text\" && block.text)\n      .map((block) => block.text);\n    return textBlocks.join(\"\\n\");\n  }\n\n  return \"\";\n}\n\n/**\n * Extract tool use information (file path, operation, etc.)\n * This captures tool_use content blocks from assistant messages\n */\nexport function extractToolUse(\n  contentBlock: ContentBlock,\n  sessionId: string,\n  timestamp?: string,\n): ToolUse | null {\n  try {\n    const toolName = contentBlock.name;\n    const input: ToolInput = contentBlock.input || {};\n\n    if (!toolName) return null;\n\n    // Extract file path from various tool formats\n    let filePath: string | undefined;\n    let content: string | undefined;\n\n    // Write tool (file creation)\n    if (toolName === \"Write\" || toolName === \"write\") {\n      filePath = input.file_path || input.path;\n      content = input.content || input.contents;\n    }\n    // Edit tool (StrReplace in Claude Code)\n    else if (toolName === \"Edit\" || toolName === \"StrReplace\" || toolName === \"str_replace\") {\n      filePath = input.file_path || input.path;\n    }\n    // Delete tool (file deletion)\n    else if (toolName === \"Delete\" || toolName === \"delete\" || toolName === \"rm\") {\n      filePath = input.file_path || input.path;\n    }\n    // EditNotebook tool\n    else if (toolName === \"EditNotebook\" || toolName === \"edit_notebook\") {\n      filePath = input.target_notebook || input.notebook_path;\n    }\n    // Read tool (also tracking reads for context)\n    else if (toolName === \"Read\" || toolName === \"read\") {\n      filePath = input.file_path || input.path;\n    }\n\n    if (!filePath) {\n      // Try generic path fields\n      filePath = input.path || input.file_path || input.filepath;\n    }\n\n    if (!filePath) {\n      return null;\n    }\n\n    const toolUse: ToolUse = {\n      session_id: sessionId,\n      tool_name: toolName,\n      file_path: filePath,\n      content: content?.substring(0, MAX_CONTENT_PREVIEW_LENGTH),\n      timestamp: timestamp || new Date().toISOString(),\n    };\n\n    // For Write operations (file creation), generate diff from content\n    // This is needed because toolUseResult might not have newString for new files\n    if ((toolName === \"Write\" || toolName === \"write\") && content) {\n      toolUse.diff = sanitizeDiff({ old_string: \"\", new_string: content }, filePath);\n    }\n\n    return toolUse;\n  } catch (error) {\n    logger.debug(\"Failed to extract tool use:\", error);\n    return null;\n  }\n}\n\n/**\n * Determine tool name based on operation type\n * Maps Claude's toolUseResult.type to our standard tool names\n */\nfunction getToolNameFromResultType(type?: string, oldString?: string, newString?: string): string {\n  // Explicit type from Claude\n  if (type === \"create\") return \"Write\";\n  if (type === \"delete\") return \"Delete\";\n\n  // Infer from content: if no old content but has new content, it's a create\n  if (!oldString && newString) return \"Write\";\n\n  // Infer from content: if has old content but no new content, it's a delete\n  if (oldString && !newString) return \"Delete\";\n\n  // Default to Edit for modifications\n  return \"Edit\";\n}\n\n/**\n * Extract tool use result with code diffs\n *\n * Handles:\n * - File creation (type: \"create\", or oldString empty with newString present)\n * - File editing (type: \"edit\", or both oldString and newString present)\n * - File deletion (type: \"delete\", or oldString present with newString empty)\n */\nexport function extractToolUseResult(entry: ClaudeJSONLEntry, sessionId: string): ToolUse | null {\n  try {\n    const result = entry.toolUseResult;\n    if (!result || !result.filePath) return null;\n\n    const toolName = getToolNameFromResultType(result.type, result.oldString, result.newString);\n\n    const toolUse: ToolUse = {\n      session_id: sessionId,\n      tool_name: toolName,\n      file_path: result.filePath,\n      timestamp: entry.timestamp || new Date().toISOString(),\n    };\n\n    // Add diff information if available\n    // sanitizeDiff now handles file creation (empty old) and deletion (empty new)\n    if (\n      result.structuredPatch ||\n      result.oldString !== undefined ||\n      result.newString !== undefined\n    ) {\n      const rawDiff = {\n        old_string: result.oldString,\n        new_string: result.newString,\n        structured_patch: result.structuredPatch,\n      };\n      toolUse.diff = sanitizeDiff(rawDiff, result.filePath);\n    }\n\n    return toolUse;\n  } catch (error) {\n    logger.debug(\"Failed to extract tool use result:\", error);\n    return null;\n  }\n}\n\n/**\n * Extract session title from first user message\n */\nexport function extractSessionTitleFromContent(content: string): string | null {\n  const lines = content.split(\"\\n\").filter((line) => line.trim());\n\n  // Find first user message\n  for (const line of lines) {\n    try {\n      const entry: ClaudeJSONLEntry = JSON.parse(line);\n      if (entry.message?.role === \"user\" && entry.message.content) {\n        const text = extractTextContent(entry.message.content);\n        if (text && text.length >= MIN_SESSION_TITLE_LENGTH) {\n          // Use first MAX_SESSION_TITLE_LENGTH characters as title\n          return text.substring(0, MAX_SESSION_TITLE_LENGTH).trim();\n        }\n      }\n    } catch {\n      // Skip invalid lines\n    }\n  }\n\n  return null;\n}\n\n/**\n * Generate a deterministic message ID\n */\nexport function generateMessageId(sessionId: string, messageIndex: number): string {\n  const hash = createHash(\"sha256\").update(`${sessionId}-${messageIndex}`).digest(\"hex\");\n  return `msg_${hash.substring(0, 16)}`;\n}\n\n/**\n * Log code diff information\n */\nexport function logDiff(filePath: string, diff?: string): void {\n  if (!diff) return;\n\n  logger.info(`Code change detected in ${filePath}:`);\n\n  // Log first few lines of the unified diff\n  const lines = diff.split(\"\\n\").slice(0, 10);\n  for (const line of lines) {\n    logger.info(`  ${line}`);\n  }\n  if (diff.split(\"\\n\").length > 10) {\n    logger.info(\"  ...\");\n  }\n}\n",
    "var Diff = /** @class */ (function () {\n    function Diff() {\n    }\n    Diff.prototype.diff = function (oldString, newString, \n    // Type below is not accurate/complete - see above for full possibilities - but it compiles\n    options) {\n        if (options === void 0) { options = {}; }\n        var callback;\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        else if ('callback' in options) {\n            callback = options.callback;\n        }\n        // Allow subclasses to massage the input prior to running\n        oldString = this.castInput(oldString, options);\n        newString = this.castInput(newString, options);\n        var oldTokens = this.removeEmpty(this.tokenize(oldString, options));\n        var newTokens = this.removeEmpty(this.tokenize(newString, options));\n        return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);\n    };\n    Diff.prototype.diffWithOptionsObj = function (oldTokens, newTokens, options, callback) {\n        var _this = this;\n        var _a;\n        var done = function (value) {\n            value = _this.postProcess(value, options);\n            if (callback) {\n                setTimeout(function () { callback(value); }, 0);\n                return undefined;\n            }\n            else {\n                return value;\n            }\n        };\n        var newLen = newTokens.length, oldLen = oldTokens.length;\n        var editLength = 1;\n        var maxEditLength = newLen + oldLen;\n        if (options.maxEditLength != null) {\n            maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n        }\n        var maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;\n        var abortAfterTimestamp = Date.now() + maxExecutionTime;\n        var bestPath = [{ oldPos: -1, lastComponent: undefined }];\n        // Seed editLength = 0, i.e. the content starts with the same values\n        var newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);\n        if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n            // Identity per the equality and tokenizer\n            return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));\n        }\n        // Once we hit the right edge of the edit graph on some diagonal k, we can\n        // definitely reach the end of the edit graph in no more than k edits, so\n        // there's no point in considering any moves to diagonal k+1 any more (from\n        // which we're guaranteed to need at least k+1 more edits).\n        // Similarly, once we've reached the bottom of the edit graph, there's no\n        // point considering moves to lower diagonals.\n        // We record this fact by setting minDiagonalToConsider and\n        // maxDiagonalToConsider to some finite value once we've hit the edge of\n        // the edit graph.\n        // This optimization is not faithful to the original algorithm presented in\n        // Myers's paper, which instead pointlessly extends D-paths off the end of\n        // the edit graph - see page 7 of Myers's paper which notes this point\n        // explicitly and illustrates it with a diagram. This has major performance\n        // implications for some common scenarios. For instance, to compute a diff\n        // where the new text simply appends d characters on the end of the\n        // original text of length n, the true Myers algorithm will take O(n+d^2)\n        // time while this optimization needs only O(n+d) time.\n        var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;\n        // Main worker method. checks all permutations of a given edit length for acceptance.\n        var execEditLength = function () {\n            for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {\n                var basePath = void 0;\n                var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];\n                if (removePath) {\n                    // No one else is going to attempt to use this value, clear it\n                    // @ts-expect-error - perf optimisation. This type-violating value will never be read.\n                    bestPath[diagonalPath - 1] = undefined;\n                }\n                var canAdd = false;\n                if (addPath) {\n                    // what newPos will be after we do an insertion:\n                    var addPathNewPos = addPath.oldPos - diagonalPath;\n                    canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n                }\n                var canRemove = removePath && removePath.oldPos + 1 < oldLen;\n                if (!canAdd && !canRemove) {\n                    // If this path is a terminal then prune\n                    // @ts-expect-error - perf optimisation. This type-violating value will never be read.\n                    bestPath[diagonalPath] = undefined;\n                    continue;\n                }\n                // Select the diagonal that we want to branch from. We select the prior\n                // path whose position in the old string is the farthest from the origin\n                // and does not pass the bounds of the diff graph\n                if (!canRemove || (canAdd && removePath.oldPos < addPath.oldPos)) {\n                    basePath = _this.addToPath(addPath, true, false, 0, options);\n                }\n                else {\n                    basePath = _this.addToPath(removePath, false, true, 1, options);\n                }\n                newPos = _this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);\n                if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n                    // If we have hit the end of both strings, then we are done\n                    return done(_this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;\n                }\n                else {\n                    bestPath[diagonalPath] = basePath;\n                    if (basePath.oldPos + 1 >= oldLen) {\n                        maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n                    }\n                    if (newPos + 1 >= newLen) {\n                        minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n                    }\n                }\n            }\n            editLength++;\n        };\n        // Performs the length of edit iteration. Is a bit fugly as this has to support the\n        // sync and async mode which is never fun. Loops over execEditLength until a value\n        // is produced, or until the edit length exceeds options.maxEditLength (if given),\n        // in which case it will return undefined.\n        if (callback) {\n            (function exec() {\n                setTimeout(function () {\n                    if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n                        return callback(undefined);\n                    }\n                    if (!execEditLength()) {\n                        exec();\n                    }\n                }, 0);\n            }());\n        }\n        else {\n            while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n                var ret = execEditLength();\n                if (ret) {\n                    return ret;\n                }\n            }\n        }\n    };\n    Diff.prototype.addToPath = function (path, added, removed, oldPosInc, options) {\n        var last = path.lastComponent;\n        if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: { count: last.count + 1, added: added, removed: removed, previousComponent: last.previousComponent }\n            };\n        }\n        else {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: { count: 1, added: added, removed: removed, previousComponent: last }\n            };\n        }\n    };\n    Diff.prototype.extractCommon = function (basePath, newTokens, oldTokens, diagonalPath, options) {\n        var newLen = newTokens.length, oldLen = oldTokens.length;\n        var oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;\n        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {\n            newPos++;\n            oldPos++;\n            commonCount++;\n            if (options.oneChangePerToken) {\n                basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };\n            }\n        }\n        if (commonCount && !options.oneChangePerToken) {\n            basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };\n        }\n        basePath.oldPos = oldPos;\n        return newPos;\n    };\n    Diff.prototype.equals = function (left, right, options) {\n        if (options.comparator) {\n            return options.comparator(left, right);\n        }\n        else {\n            return left === right\n                || (!!options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n        }\n    };\n    Diff.prototype.removeEmpty = function (array) {\n        var ret = [];\n        for (var i = 0; i < array.length; i++) {\n            if (array[i]) {\n                ret.push(array[i]);\n            }\n        }\n        return ret;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    Diff.prototype.castInput = function (value, options) {\n        return value;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    Diff.prototype.tokenize = function (value, options) {\n        return Array.from(value);\n    };\n    Diff.prototype.join = function (chars) {\n        // Assumes ValueT is string, which is the case for most subclasses.\n        // When it's false, e.g. in diffArrays, this method needs to be overridden (e.g. with a no-op)\n        // Yes, the casts are verbose and ugly, because this pattern - of having the base class SORT OF\n        // assume tokens and values are strings, but not completely - is weird and janky.\n        return chars.join('');\n    };\n    Diff.prototype.postProcess = function (changeObjects, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    options) {\n        return changeObjects;\n    };\n    Object.defineProperty(Diff.prototype, \"useLongestToken\", {\n        get: function () {\n            return false;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Diff.prototype.buildValues = function (lastComponent, newTokens, oldTokens) {\n        // First we convert our linked list of components in reverse order to an\n        // array in the right order:\n        var components = [];\n        var nextComponent;\n        while (lastComponent) {\n            components.push(lastComponent);\n            nextComponent = lastComponent.previousComponent;\n            delete lastComponent.previousComponent;\n            lastComponent = nextComponent;\n        }\n        components.reverse();\n        var componentLen = components.length;\n        var componentPos = 0, newPos = 0, oldPos = 0;\n        for (; componentPos < componentLen; componentPos++) {\n            var component = components[componentPos];\n            if (!component.removed) {\n                if (!component.added && this.useLongestToken) {\n                    var value = newTokens.slice(newPos, newPos + component.count);\n                    value = value.map(function (value, i) {\n                        var oldValue = oldTokens[oldPos + i];\n                        return oldValue.length > value.length ? oldValue : value;\n                    });\n                    component.value = this.join(value);\n                }\n                else {\n                    component.value = this.join(newTokens.slice(newPos, newPos + component.count));\n                }\n                newPos += component.count;\n                // Common case\n                if (!component.added) {\n                    oldPos += component.count;\n                }\n            }\n            else {\n                component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));\n                oldPos += component.count;\n            }\n        }\n        return components;\n    };\n    return Diff;\n}());\nexport default Diff;\n",
    "var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Diff from './base.js';\nvar CharacterDiff = /** @class */ (function (_super) {\n    __extends(CharacterDiff, _super);\n    function CharacterDiff() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CharacterDiff;\n}(Diff));\nexport var characterDiff = new CharacterDiff();\nexport function diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n}\n",
    "export function longestCommonPrefix(str1, str2) {\n    var i;\n    for (i = 0; i < str1.length && i < str2.length; i++) {\n        if (str1[i] != str2[i]) {\n            return str1.slice(0, i);\n        }\n    }\n    return str1.slice(0, i);\n}\nexport function longestCommonSuffix(str1, str2) {\n    var i;\n    // Unlike longestCommonPrefix, we need a special case to handle all scenarios\n    // where we return the empty string since str1.slice(-0) will return the\n    // entire string.\n    if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {\n        return '';\n    }\n    for (i = 0; i < str1.length && i < str2.length; i++) {\n        if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {\n            return str1.slice(-i);\n        }\n    }\n    return str1.slice(-i);\n}\nexport function replacePrefix(string, oldPrefix, newPrefix) {\n    if (string.slice(0, oldPrefix.length) != oldPrefix) {\n        throw Error(\"string \".concat(JSON.stringify(string), \" doesn't start with prefix \").concat(JSON.stringify(oldPrefix), \"; this is a bug\"));\n    }\n    return newPrefix + string.slice(oldPrefix.length);\n}\nexport function replaceSuffix(string, oldSuffix, newSuffix) {\n    if (!oldSuffix) {\n        return string + newSuffix;\n    }\n    if (string.slice(-oldSuffix.length) != oldSuffix) {\n        throw Error(\"string \".concat(JSON.stringify(string), \" doesn't end with suffix \").concat(JSON.stringify(oldSuffix), \"; this is a bug\"));\n    }\n    return string.slice(0, -oldSuffix.length) + newSuffix;\n}\nexport function removePrefix(string, oldPrefix) {\n    return replacePrefix(string, oldPrefix, '');\n}\nexport function removeSuffix(string, oldSuffix) {\n    return replaceSuffix(string, oldSuffix, '');\n}\nexport function maximumOverlap(string1, string2) {\n    return string2.slice(0, overlapCount(string1, string2));\n}\n// Nicked from https://stackoverflow.com/a/60422853/1709587\nfunction overlapCount(a, b) {\n    // Deal with cases where the strings differ in length\n    var startA = 0;\n    if (a.length > b.length) {\n        startA = a.length - b.length;\n    }\n    var endB = b.length;\n    if (a.length < b.length) {\n        endB = a.length;\n    }\n    // Create a back-reference for each index\n    //   that should be followed in case of a mismatch.\n    //   We only need B to make these references:\n    var map = Array(endB);\n    var k = 0; // Index that lags behind j\n    map[0] = 0;\n    for (var j = 1; j < endB; j++) {\n        if (b[j] == b[k]) {\n            map[j] = map[k]; // skip over the same character (optional optimisation)\n        }\n        else {\n            map[j] = k;\n        }\n        while (k > 0 && b[j] != b[k]) {\n            k = map[k];\n        }\n        if (b[j] == b[k]) {\n            k++;\n        }\n    }\n    // Phase 2: use these references while iterating over A\n    k = 0;\n    for (var i = startA; i < a.length; i++) {\n        while (k > 0 && a[i] != b[k]) {\n            k = map[k];\n        }\n        if (a[i] == b[k]) {\n            k++;\n        }\n    }\n    return k;\n}\n/**\n * Returns true if the string consistently uses Windows line endings.\n */\nexport function hasOnlyWinLineEndings(string) {\n    return string.includes('\\r\\n') && !string.startsWith('\\n') && !string.match(/[^\\r]\\n/);\n}\n/**\n * Returns true if the string consistently uses Unix line endings.\n */\nexport function hasOnlyUnixLineEndings(string) {\n    return !string.includes('\\r\\n') && string.includes('\\n');\n}\nexport function trailingWs(string) {\n    // Yes, this looks overcomplicated and dumb - why not replace the whole function with\n    //     return string match(/\\s*$/)[0]\n    // you ask? Because:\n    // 1. the trap described at https://markamery.com/blog/quadratic-time-regexes/ would mean doing\n    //    this would cause this function to take O(n²) time in the worst case (specifically when\n    //    there is a massive run of NON-TRAILING whitespace in `string`), and\n    // 2. the fix proposed in the same blog post, of using a negative lookbehind, is incompatible\n    //    with old Safari versions that we'd like to not break if possible (see\n    //    https://github.com/kpdecker/jsdiff/pull/550)\n    // It feels absurd to do this with an explicit loop instead of a regex, but I really can't see a\n    // better way that doesn't result in broken behaviour.\n    var i;\n    for (i = string.length - 1; i >= 0; i--) {\n        if (!string[i].match(/\\s/)) {\n            break;\n        }\n    }\n    return string.substring(i + 1);\n}\nexport function leadingWs(string) {\n    // Thankfully the annoying considerations described in trailingWs don't apply here:\n    var match = string.match(/^\\s*/);\n    return match ? match[0] : '';\n}\n",
    "var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Diff from './base.js';\nimport { longestCommonPrefix, longestCommonSuffix, replacePrefix, replaceSuffix, removePrefix, removeSuffix, maximumOverlap, leadingWs, trailingWs } from '../util/string.js';\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nvar extendedWordChars = 'a-zA-Z0-9_\\\\u{C0}-\\\\u{FF}\\\\u{D8}-\\\\u{F6}\\\\u{F8}-\\\\u{2C6}\\\\u{2C8}-\\\\u{2D7}\\\\u{2DE}-\\\\u{2FF}\\\\u{1E00}-\\\\u{1EFF}';\n// Each token is one of the following:\n// - A punctuation mark plus the surrounding whitespace\n// - A word plus the surrounding whitespace\n// - Pure whitespace (but only in the special case where this the entire text\n//   is just whitespace)\n//\n// We have to include surrounding whitespace in the tokens because the two\n// alternative approaches produce horribly broken results:\n// * If we just discard the whitespace, we can't fully reproduce the original\n//   text from the sequence of tokens and any attempt to render the diff will\n//   get the whitespace wrong.\n// * If we have separate tokens for whitespace, then in a typical text every\n//   second token will be a single space character. But this often results in\n//   the optimal diff between two texts being a perverse one that preserves\n//   the spaces between words but deletes and reinserts actual common words.\n//   See https://github.com/kpdecker/jsdiff/issues/160#issuecomment-1866099640\n//   for an example.\n//\n// Keeping the surrounding whitespace of course has implications for .equals\n// and .join, not just .tokenize.\n// This regex does NOT fully implement the tokenization rules described above.\n// Instead, it gives runs of whitespace their own \"token\". The tokenize method\n// then handles stitching whitespace tokens onto adjacent word or punctuation\n// tokens.\nvar tokenizeIncludingWhitespace = new RegExp(\"[\".concat(extendedWordChars, \"]+|\\\\s+|[^\").concat(extendedWordChars, \"]\"), 'ug');\nvar WordDiff = /** @class */ (function (_super) {\n    __extends(WordDiff, _super);\n    function WordDiff() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    WordDiff.prototype.equals = function (left, right, options) {\n        if (options.ignoreCase) {\n            left = left.toLowerCase();\n            right = right.toLowerCase();\n        }\n        return left.trim() === right.trim();\n    };\n    WordDiff.prototype.tokenize = function (value, options) {\n        if (options === void 0) { options = {}; }\n        var parts;\n        if (options.intlSegmenter) {\n            var segmenter = options.intlSegmenter;\n            if (segmenter.resolvedOptions().granularity != 'word') {\n                throw new Error('The segmenter passed must have a granularity of \"word\"');\n            }\n            parts = Array.from(segmenter.segment(value), function (segment) { return segment.segment; });\n        }\n        else {\n            parts = value.match(tokenizeIncludingWhitespace) || [];\n        }\n        var tokens = [];\n        var prevPart = null;\n        parts.forEach(function (part) {\n            if ((/\\s/).test(part)) {\n                if (prevPart == null) {\n                    tokens.push(part);\n                }\n                else {\n                    tokens.push(tokens.pop() + part);\n                }\n            }\n            else if (prevPart != null && (/\\s/).test(prevPart)) {\n                if (tokens[tokens.length - 1] == prevPart) {\n                    tokens.push(tokens.pop() + part);\n                }\n                else {\n                    tokens.push(prevPart + part);\n                }\n            }\n            else {\n                tokens.push(part);\n            }\n            prevPart = part;\n        });\n        return tokens;\n    };\n    WordDiff.prototype.join = function (tokens) {\n        // Tokens being joined here will always have appeared consecutively in the\n        // same text, so we can simply strip off the leading whitespace from all the\n        // tokens except the first (and except any whitespace-only tokens - but such\n        // a token will always be the first and only token anyway) and then join them\n        // and the whitespace around words and punctuation will end up correct.\n        return tokens.map(function (token, i) {\n            if (i == 0) {\n                return token;\n            }\n            else {\n                return token.replace((/^\\s+/), '');\n            }\n        }).join('');\n    };\n    WordDiff.prototype.postProcess = function (changes, options) {\n        if (!changes || options.oneChangePerToken) {\n            return changes;\n        }\n        var lastKeep = null;\n        // Change objects representing any insertion or deletion since the last\n        // \"keep\" change object. There can be at most one of each.\n        var insertion = null;\n        var deletion = null;\n        changes.forEach(function (change) {\n            if (change.added) {\n                insertion = change;\n            }\n            else if (change.removed) {\n                deletion = change;\n            }\n            else {\n                if (insertion || deletion) { // May be false at start of text\n                    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);\n                }\n                lastKeep = change;\n                insertion = null;\n                deletion = null;\n            }\n        });\n        if (insertion || deletion) {\n            dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);\n        }\n        return changes;\n    };\n    return WordDiff;\n}(Diff));\nexport var wordDiff = new WordDiff();\nexport function diffWords(oldStr, newStr, options) {\n    // This option has never been documented and never will be (it's clearer to\n    // just call `diffWordsWithSpace` directly if you need that behavior), but\n    // has existed in jsdiff for a long time, so we retain support for it here\n    // for the sake of backwards compatibility.\n    if ((options === null || options === void 0 ? void 0 : options.ignoreWhitespace) != null && !options.ignoreWhitespace) {\n        return diffWordsWithSpace(oldStr, newStr, options);\n    }\n    return wordDiff.diff(oldStr, newStr, options);\n}\nfunction dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {\n    // Before returning, we tidy up the leading and trailing whitespace of the\n    // change objects to eliminate cases where trailing whitespace in one object\n    // is repeated as leading whitespace in the next.\n    // Below are examples of the outcomes we want here to explain the code.\n    // I=insert, K=keep, D=delete\n    // 1. diffing 'foo bar baz' vs 'foo baz'\n    //    Prior to cleanup, we have K:'foo ' D:' bar ' K:' baz'\n    //    After cleanup, we want:   K:'foo ' D:'bar ' K:'baz'\n    //\n    // 2. Diffing 'foo bar baz' vs 'foo qux baz'\n    //    Prior to cleanup, we have K:'foo ' D:' bar ' I:' qux ' K:' baz'\n    //    After cleanup, we want K:'foo ' D:'bar' I:'qux' K:' baz'\n    //\n    // 3. Diffing 'foo\\nbar baz' vs 'foo baz'\n    //    Prior to cleanup, we have K:'foo ' D:'\\nbar ' K:' baz'\n    //    After cleanup, we want K'foo' D:'\\nbar' K:' baz'\n    //\n    // 4. Diffing 'foo baz' vs 'foo\\nbar baz'\n    //    Prior to cleanup, we have K:'foo\\n' I:'\\nbar ' K:' baz'\n    //    After cleanup, we ideally want K'foo' I:'\\nbar' K:' baz'\n    //    but don't actually manage this currently (the pre-cleanup change\n    //    objects don't contain enough information to make it possible).\n    //\n    // 5. Diffing 'foo   bar baz' vs 'foo  baz'\n    //    Prior to cleanup, we have K:'foo  ' D:'   bar ' K:'  baz'\n    //    After cleanup, we want K:'foo  ' D:' bar ' K:'baz'\n    //\n    // Our handling is unavoidably imperfect in the case where there's a single\n    // indel between keeps and the whitespace has changed. For instance, consider\n    // diffing 'foo\\tbar\\nbaz' vs 'foo baz'. Unless we create an extra change\n    // object to represent the insertion of the space character (which isn't even\n    // a token), we have no way to avoid losing information about the texts'\n    // original whitespace in the result we return. Still, we do our best to\n    // output something that will look sensible if we e.g. print it with\n    // insertions in green and deletions in red.\n    // Between two \"keep\" change objects (or before the first or after the last\n    // change object), we can have either:\n    // * A \"delete\" followed by an \"insert\"\n    // * Just an \"insert\"\n    // * Just a \"delete\"\n    // We handle the three cases separately.\n    if (deletion && insertion) {\n        var oldWsPrefix = leadingWs(deletion.value);\n        var oldWsSuffix = trailingWs(deletion.value);\n        var newWsPrefix = leadingWs(insertion.value);\n        var newWsSuffix = trailingWs(insertion.value);\n        if (startKeep) {\n            var commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);\n            startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);\n            deletion.value = removePrefix(deletion.value, commonWsPrefix);\n            insertion.value = removePrefix(insertion.value, commonWsPrefix);\n        }\n        if (endKeep) {\n            var commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);\n            endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);\n            deletion.value = removeSuffix(deletion.value, commonWsSuffix);\n            insertion.value = removeSuffix(insertion.value, commonWsSuffix);\n        }\n    }\n    else if (insertion) {\n        // The whitespaces all reflect what was in the new text rather than\n        // the old, so we essentially have no information about whitespace\n        // insertion or deletion. We just want to dedupe the whitespace.\n        // We do that by having each change object keep its trailing\n        // whitespace and deleting duplicate leading whitespace where\n        // present.\n        if (startKeep) {\n            var ws = leadingWs(insertion.value);\n            insertion.value = insertion.value.substring(ws.length);\n        }\n        if (endKeep) {\n            var ws = leadingWs(endKeep.value);\n            endKeep.value = endKeep.value.substring(ws.length);\n        }\n        // otherwise we've got a deletion and no insertion\n    }\n    else if (startKeep && endKeep) {\n        var newWsFull = leadingWs(endKeep.value), delWsStart = leadingWs(deletion.value), delWsEnd = trailingWs(deletion.value);\n        // Any whitespace that comes straight after startKeep in both the old and\n        // new texts, assign to startKeep and remove from the deletion.\n        var newWsStart = longestCommonPrefix(newWsFull, delWsStart);\n        deletion.value = removePrefix(deletion.value, newWsStart);\n        // Any whitespace that comes straight before endKeep in both the old and\n        // new texts, and hasn't already been assigned to startKeep, assign to\n        // endKeep and remove from the deletion.\n        var newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);\n        deletion.value = removeSuffix(deletion.value, newWsEnd);\n        endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);\n        // If there's any whitespace from the new text that HASN'T already been\n        // assigned, assign it to the start:\n        startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));\n    }\n    else if (endKeep) {\n        // We are at the start of the text. Preserve all the whitespace on\n        // endKeep, and just remove whitespace from the end of deletion to the\n        // extent that it overlaps with the start of endKeep.\n        var endKeepWsPrefix = leadingWs(endKeep.value);\n        var deletionWsSuffix = trailingWs(deletion.value);\n        var overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);\n        deletion.value = removeSuffix(deletion.value, overlap);\n    }\n    else if (startKeep) {\n        // We are at the END of the text. Preserve all the whitespace on\n        // startKeep, and just remove whitespace from the start of deletion to\n        // the extent that it overlaps with the end of startKeep.\n        var startKeepWsSuffix = trailingWs(startKeep.value);\n        var deletionWsPrefix = leadingWs(deletion.value);\n        var overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);\n        deletion.value = removePrefix(deletion.value, overlap);\n    }\n}\nvar WordsWithSpaceDiff = /** @class */ (function (_super) {\n    __extends(WordsWithSpaceDiff, _super);\n    function WordsWithSpaceDiff() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    WordsWithSpaceDiff.prototype.tokenize = function (value) {\n        // Slightly different to the tokenizeIncludingWhitespace regex used above in\n        // that this one treats each individual newline as a distinct tokens, rather\n        // than merging them into other surrounding whitespace. This was requested\n        // in https://github.com/kpdecker/jsdiff/issues/180 &\n        //    https://github.com/kpdecker/jsdiff/issues/211\n        var regex = new RegExp(\"(\\\\r?\\\\n)|[\".concat(extendedWordChars, \"]+|[^\\\\S\\\\n\\\\r]+|[^\").concat(extendedWordChars, \"]\"), 'ug');\n        return value.match(regex) || [];\n    };\n    return WordsWithSpaceDiff;\n}(Diff));\nexport var wordsWithSpaceDiff = new WordsWithSpaceDiff();\nexport function diffWordsWithSpace(oldStr, newStr, options) {\n    return wordsWithSpaceDiff.diff(oldStr, newStr, options);\n}\n",
    "var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Diff from './base.js';\nimport { generateOptions } from '../util/params.js';\nvar LineDiff = /** @class */ (function (_super) {\n    __extends(LineDiff, _super);\n    function LineDiff() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.tokenize = tokenize;\n        return _this;\n    }\n    LineDiff.prototype.equals = function (left, right, options) {\n        // If we're ignoring whitespace, we need to normalise lines by stripping\n        // whitespace before checking equality. (This has an annoying interaction\n        // with newlineIsToken that requires special handling: if newlines get their\n        // own token, then we DON'T want to trim the *newline* tokens down to empty\n        // strings, since this would cause us to treat whitespace-only line content\n        // as equal to a separator between lines, which would be weird and\n        // inconsistent with the documented behavior of the options.)\n        if (options.ignoreWhitespace) {\n            if (!options.newlineIsToken || !left.includes('\\n')) {\n                left = left.trim();\n            }\n            if (!options.newlineIsToken || !right.includes('\\n')) {\n                right = right.trim();\n            }\n        }\n        else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {\n            if (left.endsWith('\\n')) {\n                left = left.slice(0, -1);\n            }\n            if (right.endsWith('\\n')) {\n                right = right.slice(0, -1);\n            }\n        }\n        return _super.prototype.equals.call(this, left, right, options);\n    };\n    return LineDiff;\n}(Diff));\nexport var lineDiff = new LineDiff();\nexport function diffLines(oldStr, newStr, options) {\n    return lineDiff.diff(oldStr, newStr, options);\n}\nexport function diffTrimmedLines(oldStr, newStr, options) {\n    options = generateOptions(options, { ignoreWhitespace: true });\n    return lineDiff.diff(oldStr, newStr, options);\n}\n// Exported standalone so it can be used from jsonDiff too.\nexport function tokenize(value, options) {\n    if (options.stripTrailingCr) {\n        // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n        value = value.replace(/\\r\\n/g, '\\n');\n    }\n    var retLines = [], linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n    // Ignore the final empty token that occurs if the string ends with a new line\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n        linesAndNewlines.pop();\n    }\n    // Merge the content and line separators into single tokens\n    for (var i = 0; i < linesAndNewlines.length; i++) {\n        var line = linesAndNewlines[i];\n        if (i % 2 && !options.newlineIsToken) {\n            retLines[retLines.length - 1] += line;\n        }\n        else {\n            retLines.push(line);\n        }\n    }\n    return retLines;\n}\n",
    "var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Diff from './base.js';\nvar SentenceDiff = /** @class */ (function (_super) {\n    __extends(SentenceDiff, _super);\n    function SentenceDiff() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SentenceDiff.prototype.tokenize = function (value) {\n        return value.split(/(?<=[.!?])(\\s+|$)/);\n    };\n    return SentenceDiff;\n}(Diff));\nexport var sentenceDiff = new SentenceDiff();\nexport function diffSentences(oldStr, newStr, options) {\n    return sentenceDiff.diff(oldStr, newStr, options);\n}\n",
    "var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Diff from './base.js';\nvar CssDiff = /** @class */ (function (_super) {\n    __extends(CssDiff, _super);\n    function CssDiff() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CssDiff.prototype.tokenize = function (value) {\n        return value.split(/([{}:;,]|\\s+)/);\n    };\n    return CssDiff;\n}(Diff));\nexport var cssDiff = new CssDiff();\nexport function diffCss(oldStr, newStr, options) {\n    return cssDiff.diff(oldStr, newStr, options);\n}\n",
    "var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Diff from './base.js';\nimport { tokenize } from './line.js';\nvar JsonDiff = /** @class */ (function (_super) {\n    __extends(JsonDiff, _super);\n    function JsonDiff() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.tokenize = tokenize;\n        return _this;\n    }\n    Object.defineProperty(JsonDiff.prototype, \"useLongestToken\", {\n        get: function () {\n            // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n            // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n            return true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    JsonDiff.prototype.castInput = function (value, options) {\n        var undefinedReplacement = options.undefinedReplacement, _a = options.stringifyReplacer, stringifyReplacer = _a === void 0 ? function (k, v) { return typeof v === 'undefined' ? undefinedReplacement : v; } : _a;\n        return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), null, '  ');\n    };\n    JsonDiff.prototype.equals = function (left, right, options) {\n        return _super.prototype.equals.call(this, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'), options);\n    };\n    return JsonDiff;\n}(Diff));\nexport var jsonDiff = new JsonDiff();\nexport function diffJson(oldStr, newStr, options) {\n    return jsonDiff.diff(oldStr, newStr, options);\n}\n// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nexport function canonicalize(obj, stack, replacementStack, replacer, key) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n    if (replacer) {\n        obj = replacer(key === undefined ? '' : key, obj);\n    }\n    var i;\n    for (i = 0; i < stack.length; i += 1) {\n        if (stack[i] === obj) {\n            return replacementStack[i];\n        }\n    }\n    var canonicalizedObj;\n    if ('[object Array]' === Object.prototype.toString.call(obj)) {\n        stack.push(obj);\n        canonicalizedObj = new Array(obj.length);\n        replacementStack.push(canonicalizedObj);\n        for (i = 0; i < obj.length; i += 1) {\n            canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, String(i));\n        }\n        stack.pop();\n        replacementStack.pop();\n        return canonicalizedObj;\n    }\n    if (obj && obj.toJSON) {\n        obj = obj.toJSON();\n    }\n    if (typeof obj === 'object' && obj !== null) {\n        stack.push(obj);\n        canonicalizedObj = {};\n        replacementStack.push(canonicalizedObj);\n        var sortedKeys = [];\n        var key_1;\n        for (key_1 in obj) {\n            /* istanbul ignore else */\n            if (Object.prototype.hasOwnProperty.call(obj, key_1)) {\n                sortedKeys.push(key_1);\n            }\n        }\n        sortedKeys.sort();\n        for (i = 0; i < sortedKeys.length; i += 1) {\n            key_1 = sortedKeys[i];\n            canonicalizedObj[key_1] = canonicalize(obj[key_1], stack, replacementStack, replacer, key_1);\n        }\n        stack.pop();\n        replacementStack.pop();\n    }\n    else {\n        canonicalizedObj = obj;\n    }\n    return canonicalizedObj;\n}\n",
    "var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Diff from './base.js';\nvar ArrayDiff = /** @class */ (function (_super) {\n    __extends(ArrayDiff, _super);\n    function ArrayDiff() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ArrayDiff.prototype.tokenize = function (value) {\n        return value.slice();\n    };\n    ArrayDiff.prototype.join = function (value) {\n        return value;\n    };\n    ArrayDiff.prototype.removeEmpty = function (value) {\n        return value;\n    };\n    return ArrayDiff;\n}(Diff));\nexport var arrayDiff = new ArrayDiff();\nexport function diffArrays(oldArr, newArr, options) {\n    return arrayDiff.diff(oldArr, newArr, options);\n}\n",
    "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { diffLines } from '../diff/line.js';\nexport function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    var optionsObj;\n    if (!options) {\n        optionsObj = {};\n    }\n    else if (typeof options === 'function') {\n        optionsObj = { callback: options };\n    }\n    else {\n        optionsObj = options;\n    }\n    if (typeof optionsObj.context === 'undefined') {\n        optionsObj.context = 4;\n    }\n    // We copy this into its own variable to placate TypeScript, which thinks\n    // optionsObj.context might be undefined in the callbacks below.\n    var context = optionsObj.context;\n    // @ts-expect-error (runtime check for something that is correctly a static type error)\n    if (optionsObj.newlineIsToken) {\n        throw new Error('newlineIsToken may not be used with patch-generation functions, only with diffing functions');\n    }\n    if (!optionsObj.callback) {\n        return diffLinesResultToPatch(diffLines(oldStr, newStr, optionsObj));\n    }\n    else {\n        var callback_1 = optionsObj.callback;\n        diffLines(oldStr, newStr, __assign(__assign({}, optionsObj), { callback: function (diff) {\n                var patch = diffLinesResultToPatch(diff);\n                // TypeScript is unhappy without the cast because it does not understand that `patch` may\n                // be undefined here only if `callback` is StructuredPatchCallbackAbortable:\n                callback_1(patch);\n            } }));\n    }\n    function diffLinesResultToPatch(diff) {\n        // STEP 1: Build up the patch with no \"\\ No newline at end of file\" lines and with the arrays\n        //         of lines containing trailing newline characters. We'll tidy up later...\n        if (!diff) {\n            return;\n        }\n        diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier\n        function contextLines(lines) {\n            return lines.map(function (entry) { return ' ' + entry; });\n        }\n        var hunks = [];\n        var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;\n        for (var i = 0; i < diff.length; i++) {\n            var current = diff[i], lines = current.lines || splitLines(current.value);\n            current.lines = lines;\n            if (current.added || current.removed) {\n                // If we have previous context, start with that\n                if (!oldRangeStart) {\n                    var prev = diff[i - 1];\n                    oldRangeStart = oldLine;\n                    newRangeStart = newLine;\n                    if (prev) {\n                        curRange = context > 0 ? contextLines(prev.lines.slice(-context)) : [];\n                        oldRangeStart -= curRange.length;\n                        newRangeStart -= curRange.length;\n                    }\n                }\n                // Output our changes\n                for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n                    var line = lines_1[_i];\n                    curRange.push((current.added ? '+' : '-') + line);\n                }\n                // Track the updated file position\n                if (current.added) {\n                    newLine += lines.length;\n                }\n                else {\n                    oldLine += lines.length;\n                }\n            }\n            else {\n                // Identical context lines. Track line changes\n                if (oldRangeStart) {\n                    // Close out any changes that have been output (or join overlapping)\n                    if (lines.length <= context * 2 && i < diff.length - 2) {\n                        // Overlapping\n                        for (var _a = 0, _b = contextLines(lines); _a < _b.length; _a++) {\n                            var line = _b[_a];\n                            curRange.push(line);\n                        }\n                    }\n                    else {\n                        // end the range and output\n                        var contextSize = Math.min(lines.length, context);\n                        for (var _c = 0, _d = contextLines(lines.slice(0, contextSize)); _c < _d.length; _c++) {\n                            var line = _d[_c];\n                            curRange.push(line);\n                        }\n                        var hunk = {\n                            oldStart: oldRangeStart,\n                            oldLines: (oldLine - oldRangeStart + contextSize),\n                            newStart: newRangeStart,\n                            newLines: (newLine - newRangeStart + contextSize),\n                            lines: curRange\n                        };\n                        hunks.push(hunk);\n                        oldRangeStart = 0;\n                        newRangeStart = 0;\n                        curRange = [];\n                    }\n                }\n                oldLine += lines.length;\n                newLine += lines.length;\n            }\n        }\n        // Step 2: eliminate the trailing `\\n` from each line of each hunk, and, where needed, add\n        //         \"\\ No newline at end of file\".\n        for (var _e = 0, hunks_1 = hunks; _e < hunks_1.length; _e++) {\n            var hunk = hunks_1[_e];\n            for (var i = 0; i < hunk.lines.length; i++) {\n                if (hunk.lines[i].endsWith('\\n')) {\n                    hunk.lines[i] = hunk.lines[i].slice(0, -1);\n                }\n                else {\n                    hunk.lines.splice(i + 1, 0, '\\\\ No newline at end of file');\n                    i++; // Skip the line we just added, then continue iterating\n                }\n            }\n        }\n        return {\n            oldFileName: oldFileName, newFileName: newFileName,\n            oldHeader: oldHeader, newHeader: newHeader,\n            hunks: hunks\n        };\n    }\n}\n/**\n * creates a unified diff patch.\n * @param patch either a single structured patch object (as returned by `structuredPatch`) or an array of them (as returned by `parsePatch`)\n */\nexport function formatPatch(patch) {\n    if (Array.isArray(patch)) {\n        return patch.map(formatPatch).join('\\n');\n    }\n    var ret = [];\n    if (patch.oldFileName == patch.newFileName) {\n        ret.push('Index: ' + patch.oldFileName);\n    }\n    ret.push('===================================================================');\n    ret.push('--- ' + patch.oldFileName + (typeof patch.oldHeader === 'undefined' ? '' : '\\t' + patch.oldHeader));\n    ret.push('+++ ' + patch.newFileName + (typeof patch.newHeader === 'undefined' ? '' : '\\t' + patch.newHeader));\n    for (var i = 0; i < patch.hunks.length; i++) {\n        var hunk = patch.hunks[i];\n        // Unified Diff Format quirk: If the chunk size is 0,\n        // the first number is one lower than one would expect.\n        // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n        if (hunk.oldLines === 0) {\n            hunk.oldStart -= 1;\n        }\n        if (hunk.newLines === 0) {\n            hunk.newStart -= 1;\n        }\n        ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines\n            + ' +' + hunk.newStart + ',' + hunk.newLines\n            + ' @@');\n        for (var _i = 0, _a = hunk.lines; _i < _a.length; _i++) {\n            var line = _a[_i];\n            ret.push(line);\n        }\n    }\n    return ret.join('\\n') + '\\n';\n}\nexport function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    if (typeof options === 'function') {\n        options = { callback: options };\n    }\n    if (!(options === null || options === void 0 ? void 0 : options.callback)) {\n        var patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n        if (!patchObj) {\n            return;\n        }\n        return formatPatch(patchObj);\n    }\n    else {\n        var callback_2 = options.callback;\n        structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, __assign(__assign({}, options), { callback: function (patchObj) {\n                if (!patchObj) {\n                    callback_2(undefined);\n                }\n                else {\n                    callback_2(formatPatch(patchObj));\n                }\n            } }));\n    }\n}\nexport function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n/**\n * Split `text` into an array of lines, including the trailing newline character (where present)\n */\nfunction splitLines(text) {\n    var hasTrailingNl = text.endsWith('\\n');\n    var result = text.split('\\n').map(function (line) { return line + '\\n'; });\n    if (hasTrailingNl) {\n        result.pop();\n    }\n    else {\n        result.push(result.pop().slice(0, -1));\n    }\n    return result;\n}\n",
    "/**\n * Diff utilities\n *\n * Functions for handling and sanitizing diff data\n */\n\nimport * as Diff from \"diff\";\nimport { MAX_DIFF_SIZE_BYTES } from \"../config/constants.js\";\nimport { logger } from \"./logger.js\";\n\n/**\n * Create a unified diff format from old and new strings\n * Uses the same library as the VSCode extension\n */\nexport function createUnifiedDiff(filePath: string, oldString: string, newString: string): string {\n  try {\n    return Diff.createPatch(filePath, oldString.trimEnd(), newString.trimEnd(), \"\", \"\", {\n      context: 3,\n    });\n  } catch (error) {\n    logger.warn(`Failed to create unified diff for ${filePath}`, error);\n    return \"\";\n  }\n}\n\n/**\n * Sanitize diff data to prevent unbounded memory growth\n * Converts old_string/new_string to unified diff format to save space\n *\n * Handles three cases:\n * - File creation: old_string is empty/undefined, new_string has content\n * - File edit: both old_string and new_string have content\n * - File deletion: old_string has content, new_string is empty/undefined\n */\nexport function sanitizeDiff(\n  diff: { old_string?: string; new_string?: string; structured_patch?: unknown } | undefined,\n  filePath?: string,\n): string | undefined {\n  if (!diff || !filePath) {\n    return undefined;\n  }\n\n  // Normalize strings - treat undefined/null as empty string\n  const oldString = diff.old_string ?? \"\";\n  const newString = diff.new_string ?? \"\";\n\n  // If both strings are empty, there's no meaningful diff\n  if (oldString === \"\" && newString === \"\") {\n    return undefined;\n  }\n\n  const unifiedDiff = createUnifiedDiff(filePath, oldString, newString);\n\n  if (!unifiedDiff) {\n    return undefined;\n  }\n\n  const sizeBytes = Buffer.byteLength(unifiedDiff, \"utf-8\");\n\n  if (sizeBytes > MAX_DIFF_SIZE_BYTES) {\n    logger.warn(\n      `Diff size ${sizeBytes} bytes exceeds limit of ${MAX_DIFF_SIZE_BYTES} bytes, skipping`,\n    );\n    return undefined;\n  }\n\n  return unifiedDiff;\n}\n",
    "/**\n * Local queue management for data persistence\n *\n * Manages JSONL queue files for events, sessions, and messages\n * Provides file locking to prevent corruption during concurrent writes\n */\n\nimport { appendFile, mkdir, readFile, stat, unlink, writeFile } from \"node:fs/promises\";\nimport { dirname } from \"node:path\";\nimport {\n  EVENTS_QUEUE_FILE,\n  MESSAGES_QUEUE_FILE,\n  QUEUE_DIR,\n  SESSIONS_QUEUE_FILE,\n} from \"../config/constants.js\";\nimport type {\n  ClaudeExtractedEvent,\n  ClaudeExtractedMessage,\n  ClaudeExtractedSession,\n} from \"../types/index.js\";\nimport { logger } from \"./logger.js\";\n\n// Simple file-based locking mechanism\nconst locks = new Map<string, Promise<void>>();\n\n/**\n * Acquire a lock for a file to prevent concurrent writes\n */\nasync function withLock<T>(filePath: string, fn: () => Promise<T>): Promise<T> {\n  // Wait for existing lock if present\n  while (locks.has(filePath)) {\n    await locks.get(filePath);\n  }\n\n  // Create new lock\n  let releaseLock: () => void;\n  const lockPromise = new Promise<void>((resolve) => {\n    releaseLock = resolve;\n  });\n  locks.set(filePath, lockPromise);\n\n  try {\n    return await fn();\n  } finally {\n    // Release lock\n    locks.delete(filePath);\n    releaseLock!();\n  }\n}\n\n/**\n * Ensure directory exists, creating it if necessary\n */\nasync function ensureDirectory(dirPath: string): Promise<void> {\n  try {\n    await stat(dirPath);\n  } catch {\n    await mkdir(dirPath, { recursive: true, mode: 0o700 });\n    logger.debug(`Created directory: ${dirPath}`);\n  }\n}\n\n/**\n * Append a JSON object to a JSONL file\n */\nasync function appendToJsonl(filePath: string, data: unknown): Promise<void> {\n  await withLock(filePath, async () => {\n    // Ensure directory exists\n    await ensureDirectory(dirname(filePath));\n\n    // Append JSON line\n    const line = JSON.stringify(data) + \"\\n\";\n    await appendFile(filePath, line, \"utf8\");\n  });\n}\n\n/**\n * Read all entries from a JSONL file\n */\nasync function readJsonl<T>(filePath: string): Promise<T[]> {\n  try {\n    const content = await readFile(filePath, \"utf8\");\n    const lines = content.trim().split(\"\\n\").filter(Boolean);\n\n    const results: T[] = [];\n    for (let i = 0; i < lines.length; i++) {\n      try {\n        results.push(JSON.parse(lines[i]));\n      } catch (error) {\n        logger.warn(`Failed to parse line ${i + 1} in ${filePath}:`, error);\n        // Continue processing other lines\n      }\n    }\n\n    return results;\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\n      // File doesn't exist yet, return empty array\n      return [];\n    }\n    throw error;\n  }\n}\n\n/**\n * Count lines in a JSONL file\n */\nasync function countLines(filePath: string): Promise<number> {\n  try {\n    const content = await readFile(filePath, \"utf8\");\n    const lines = content.trim().split(\"\\n\").filter(Boolean);\n    return lines.length;\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\n      return 0;\n    }\n    throw error;\n  }\n}\n\n/**\n * Delete a file (clear queue)\n */\nasync function deleteFile(filePath: string): Promise<void> {\n  try {\n    await unlink(filePath);\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\n      // File doesn't exist, nothing to delete\n      return;\n    }\n    throw error;\n  }\n}\n\n// ============================================================================\n// Public API\n// ============================================================================\n\n/**\n * Enqueue a code digest event extracted from Claude Code CLI\n */\nexport async function enqueueEvent(event: ClaudeExtractedEvent): Promise<void> {\n  try {\n    await appendToJsonl(EVENTS_QUEUE_FILE, event);\n    logger.debug(\"Enqueued event\", { eventId: event.id, documentUri: event.document_uri });\n  } catch (error) {\n    logger.error(\"Failed to enqueue event:\", error);\n    throw error;\n  }\n}\n\n/**\n * Enqueue a chat session extracted from Claude Code CLI\n */\nexport async function enqueueChatSession(session: ClaudeExtractedSession): Promise<void> {\n  try {\n    await appendToJsonl(SESSIONS_QUEUE_FILE, session);\n    logger.debug(\"Enqueued session\", { sessionId: session.id });\n  } catch (error) {\n    logger.error(\"Failed to enqueue session:\", error);\n    throw error;\n  }\n}\n\n/**\n * Enqueue a chat message extracted from Claude Code CLI\n */\nexport async function enqueueChatMessage(message: ClaudeExtractedMessage): Promise<void> {\n  try {\n    await appendToJsonl(MESSAGES_QUEUE_FILE, message);\n    logger.debug(\"Enqueued message\", {\n      sessionId: message.session_id,\n      messageIndex: message.message_index,\n    });\n  } catch (error) {\n    logger.error(\"Failed to enqueue message:\", error);\n    throw error;\n  }\n}\n\n/**\n * Read all entries from a queue file\n */\nexport async function readQueue<T>(queueFile: string): Promise<T[]> {\n  try {\n    return await readJsonl<T>(queueFile);\n  } catch (error) {\n    logger.error(`Failed to read queue file ${queueFile}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Write entries to a queue file (overwrites existing content)\n */\nexport async function writeQueue<T>(queueFile: string, items: T[]): Promise<void> {\n  try {\n    await withLock(queueFile, async () => {\n      await ensureDirectory(dirname(queueFile));\n\n      // Write all items as JSONL\n      const content =\n        items.map((item) => JSON.stringify(item)).join(\"\\n\") + (items.length > 0 ? \"\\n\" : \"\");\n      await writeFile(queueFile, content, \"utf8\");\n\n      logger.debug(`Wrote ${items.length} items to queue file: ${queueFile}`);\n    });\n  } catch (error) {\n    logger.error(`Failed to write queue file ${queueFile}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Atomically update queue files with a transform function\n * Ensures no race condition between read and write\n *\n * The entire read-modify-write cycle happens inside a lock\n */\nexport async function atomicUpdateQueue<T>(\n  queueFile: string,\n  transform: (currentItems: T[]) => T[],\n): Promise<void> {\n  try {\n    await withLock(queueFile, async () => {\n      // Read current state (inside lock)\n      const currentItems = await readJsonl<T>(queueFile);\n\n      // Apply transformation\n      const newItems = transform(currentItems);\n\n      // Write back (still inside lock)\n      await ensureDirectory(dirname(queueFile));\n      const content =\n        newItems.map((item) => JSON.stringify(item)).join(\"\\n\") + (newItems.length > 0 ? \"\\n\" : \"\");\n      await writeFile(queueFile, content, \"utf8\");\n\n      logger.debug(\n        `Atomically updated queue file: ${queueFile} (${currentItems.length} → ${newItems.length} items)`,\n      );\n    });\n  } catch (error) {\n    logger.error(`Failed to atomically update queue file ${queueFile}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Clear a queue file (delete it)\n */\nexport async function clearQueue(queueFile: string): Promise<void> {\n  try {\n    await withLock(queueFile, async () => {\n      await deleteFile(queueFile);\n      logger.debug(`Cleared queue file: ${queueFile}`);\n    });\n  } catch (error) {\n    logger.error(`Failed to clear queue file ${queueFile}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Get statistics about queued items\n */\nexport async function getQueueStats(): Promise<{\n  events: number;\n  sessions: number;\n  messages: number;\n}> {\n  try {\n    const [events, sessions, messages] = await Promise.all([\n      countLines(EVENTS_QUEUE_FILE),\n      countLines(SESSIONS_QUEUE_FILE),\n      countLines(MESSAGES_QUEUE_FILE),\n    ]);\n\n    return { events, sessions, messages };\n  } catch (error) {\n    logger.error(\"Failed to get queue stats:\", error);\n    return { events: 0, sessions: 0, messages: 0 };\n  }\n}\n\n/**\n * Ensure queue directory exists (call on initialization)\n */\nexport async function initializeQueue(): Promise<void> {\n  try {\n    await ensureDirectory(QUEUE_DIR);\n    logger.debug(\"Queue directory initialized\");\n  } catch (error) {\n    logger.error(\"Failed to initialize queue directory:\", error);\n    throw error;\n  }\n}\n",
    "/**\n * State manager for tracking extraction progress per session\n *\n * Stores last read line number for each session to enable\n * incremental extraction without re-reading entire files\n */\n\nimport { mkdir, readFile, writeFile } from \"node:fs/promises\";\nimport { join } from \"node:path\";\nimport { CLAUDE_ZEST_DIR } from \"../config/constants.js\";\nimport { logger } from \"./logger.js\";\n\nconst STATE_DIR = join(CLAUDE_ZEST_DIR, \"state\");\n\ninterface SessionState {\n  sessionId: string;\n  lastReadLine: number;\n  lastMessageIndex: number; // Last message_index that was queued\n  filePath: string;\n}\n\n/**\n * Get state file path for a session\n */\nfunction getStateFilePath(sessionId: string): string {\n  return join(STATE_DIR, `${sessionId}.json`);\n}\n\n/**\n * Ensure state directory exists\n */\nasync function ensureStateDir(): Promise<void> {\n  try {\n    await mkdir(STATE_DIR, { recursive: true });\n  } catch (error) {\n    logger.debug(\"State directory already exists or error creating:\", error);\n  }\n}\n\n/**\n * Read session state\n */\nexport async function readSessionState(sessionId: string): Promise<SessionState | null> {\n  try {\n    const stateFile = getStateFilePath(sessionId);\n    const content = await readFile(stateFile, \"utf-8\");\n    return JSON.parse(content) as SessionState;\n  } catch (error) {\n    // State file doesn't exist yet - this is normal for new sessions\n    logger.debug(`No state found for session ${sessionId} (new session)`);\n    return null;\n  }\n}\n\n/**\n * Write session state\n */\nexport async function writeSessionState(state: SessionState): Promise<void> {\n  try {\n    await ensureStateDir();\n    const stateFile = getStateFilePath(state.sessionId);\n    await writeFile(stateFile, JSON.stringify(state, null, 2), \"utf-8\");\n    logger.debug(\n      `Updated state for session ${state.sessionId}: lastReadLine=${state.lastReadLine}`,\n    );\n  } catch (error) {\n    logger.error(`Failed to write state for session ${state.sessionId}:`, error);\n  }\n}\n\n/**\n * Update last read line number and last message index for a session\n */\nexport async function updateLastReadLine(\n  sessionId: string,\n  filePath: string,\n  lineNumber: number,\n  lastMessageIndex: number,\n): Promise<void> {\n  const newState: SessionState = {\n    sessionId,\n    lastReadLine: lineNumber,\n    lastMessageIndex,\n    filePath,\n  };\n  await writeSessionState(newState);\n}\n",
    "#!/usr/bin/env node\n\n/**\n * CLI handler for session events\n *\n * Called by Claude Code hooks as a shell command\n * Usage: node dist/hooks/session-handler-cli.js <start|end>\n */\n\nimport { restartDaemon } from \"../utils/daemon-manager.js\";\nimport {\n  extractNewSessionData,\n  findConversationFile,\n  queueSessionData,\n} from \"../utils/extraction-helpers.js\";\nimport { logger } from \"../utils/logger.js\";\n\nasync function main() {\n  const eventType = process.argv[2]; // 'start' or 'end'\n\n  logger.info(`Session event: ${eventType}`);\n\n  try {\n    if (eventType === \"start\") {\n      await handleSessionStart();\n    } else if (eventType === \"end\") {\n      await handleSessionEnd();\n    }\n  } catch (error) {\n    logger.error(`Failed to handle session ${eventType} event:`, error);\n    // Exit with 0 to avoid disrupting Claude's operation\n    // The error is logged for debugging purposes\n    process.exit(0);\n  }\n}\n\n/**\n * Handle session start - restart daemon\n *\n * Restarts the sync daemon on every session start to ensure latest plugin code is running.\n * Daemon runs continuously in background, syncing every 60 seconds.\n *\n * Note: No data extraction at SessionStart to avoid duplicates.\n * Data extraction happens via:\n * - PostToolUse: Incremental extraction during session\n * - SessionEnd: Safety net for any missed data\n */\nasync function handleSessionStart() {\n  const projectDir = process.env.CLAUDE_PROJECT_DIR;\n  logger.info(`Session started in: ${projectDir || \"unknown directory\"}`);\n\n  // Restart sync daemon to pick up any plugin updates\n  try {\n    await restartDaemon();\n  } catch (error) {\n    logger.error(\"Failed to restart daemon:\", error);\n    // Don't fail the hook - session can continue, data will queue locally\n  }\n}\n\n/**\n * Handle session end - extract any remaining data (safety net for missed incremental extractions)\n */\nasync function handleSessionEnd() {\n  const startTime = Date.now();\n  logger.info(\"=== Session ended - performing final extraction (safety net) ===\");\n\n  const projectDir = process.env.CLAUDE_PROJECT_DIR;\n\n  try {\n    if (!projectDir) {\n      logger.warn(\"CLAUDE_PROJECT_DIR not set, cannot extract\");\n      return;\n    }\n\n    // Find conversation file using shared helper\n    const sessionInfo = await findConversationFile(projectDir);\n    if (!sessionInfo) {\n      logger.warn(\"Could not find conversation file\");\n      return;\n    }\n\n    const { conversationFile, sessionId, fileStats } = sessionInfo;\n\n    logger.info(`Session file: ${conversationFile}`);\n    logger.info(`Session ID: ${sessionId}`);\n    logger.info(`File modified: ${fileStats.mtime.toISOString()}`);\n\n    // Extract data from conversation file (safety net for missed incremental extractions)\n    const extractionResult = await extractNewSessionData(conversationFile, sessionId);\n\n    // If no new data, incremental extraction was successful\n    if (!extractionResult.hasNewData) {\n      logger.info(\"✓ No missed data - incremental extraction was successful\");\n      const totalTime = Date.now() - startTime;\n      logger.info(`=== SessionEnd complete in ${totalTime}ms ===`);\n      return;\n    }\n\n    // Queue extracted data\n    const { messagesQueued, eventsQueued } = await queueSessionData(\n      sessionId,\n      extractionResult.messages,\n      extractionResult.toolUses,\n      fileStats,\n      projectDir,\n      conversationFile,\n      extractionResult.newLastReadLine,\n      extractionResult.lastMessageIndex,\n      extractionResult.isNewSession,\n    );\n\n    logger.warn(\n      `⚠ Found ${messagesQueued} messages and ${eventsQueued} events that were missed by incremental extraction`,\n    );\n\n    const totalTime = Date.now() - startTime;\n    logger.info(`=== SessionEnd complete in ${totalTime}ms ===`);\n  } catch (error) {\n    logger.error(\"Failed to handle session end:\", error);\n  }\n}\n\nmain().catch((error) => {\n  console.error(\"Session handler error:\", error);\n  process.exit(1);\n});\n"
  ],
  "mappings": "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",
  "debugId": "E8B2D5730A7ACA2164756E2164756E21",
  "names": []
}