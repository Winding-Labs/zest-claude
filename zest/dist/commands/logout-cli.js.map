{
  "version": 3,
  "sources": ["..\\src\\config\\constants.ts", "..\\src\\utils\\logger.ts", "..\\src\\auth\\session-manager.ts", "..\\src\\auth\\authentication.ts", "..\\src\\commands\\logout-cli.ts"],
  "sourcesContent": [
    "/**\r\n * Application constants and configuration values\r\n */\r\n\r\nimport { homedir } from \"node:os\";\r\nimport { join } from \"node:path\";\r\n\r\n// Base directories\r\nexport const CLAUDE_ZEST_DIR = join(\r\n  homedir(),\r\n  `.claude-zest${process.env.NODE_ENV === \"development\" ? \"-dev\" : \"\"}`,\r\n);\r\nexport const QUEUE_DIR = join(CLAUDE_ZEST_DIR, \"queue\");\r\nexport const LOGS_DIR = join(CLAUDE_ZEST_DIR, \"logs\");\r\nexport const STATE_DIR = join(CLAUDE_ZEST_DIR, \"state\");\r\nexport const DELETION_CACHE_DIR = join(CLAUDE_ZEST_DIR, \"cache\", \"deletions\");\r\n\r\n// File paths\r\nexport const SESSION_FILE = join(CLAUDE_ZEST_DIR, \"session.json\"); // Auth session + workspace info\r\nexport const SETTINGS_FILE = join(CLAUDE_ZEST_DIR, \"settings.json\"); // User preferences\r\nexport const LOG_FILE = join(LOGS_DIR, \"plugin.log\");\r\nexport const SYNC_LOG_FILE = join(LOGS_DIR, \"sync.log\");\r\nexport const DAEMON_PID_FILE = join(CLAUDE_ZEST_DIR, \"daemon.pid\");\r\n\r\n// Queue files\r\nexport const EVENTS_QUEUE_FILE = join(QUEUE_DIR, \"events.jsonl\");\r\nexport const SESSIONS_QUEUE_FILE = join(QUEUE_DIR, \"chat-sessions.jsonl\");\r\nexport const MESSAGES_QUEUE_FILE = join(QUEUE_DIR, \"chat-messages.jsonl\");\r\n\r\n// Platform and source identifiers\r\nexport const PLATFORM = \"terminal\";\r\nexport const SOURCE = \"claude-code\";\r\nexport const CLIENT_ID = \"claude-cli\";\r\n\r\n// Sync configuration\r\nexport const SYNC_INTERVAL_MS = 60000; // 60 seconds\r\nexport const MAX_RETRY_ATTEMPTS = 3;\r\nexport const RETRY_BACKOFF_MS = 5000;\r\n\r\n// Cache configuration\r\nexport const DELETION_CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\r\n\r\n// Authentication configuration\r\nexport const PROACTIVE_REFRESH_THRESHOLD_MS = 5 * 60 * 1000; // Refresh tokens 5 minutes before expiration\r\n\r\n// Content size limits\r\nexport const MAX_DIFF_SIZE_BYTES = 10 * 1024 * 1024; // 10MB\r\nexport const MAX_CONTENT_PREVIEW_LENGTH = 1000; // characters\r\nexport const MAX_SESSION_TITLE_LENGTH = 100; // characters\r\nexport const MIN_SESSION_TITLE_LENGTH = 3; // characters\r\n\r\n// Session quality filters\r\nexport const MIN_MESSAGES_PER_SESSION = 3; // Minimum messages required to upload a session\r\nexport const STALE_SESSION_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\r\n\r\n// API endpoints (configured from .env at build time)\r\n// Values are baked into the bundle during build\r\nexport const WEB_APP_URL = process.env.ZEST_WEB_APP_URL || \"http://localhost:3000\";\r\nexport const SUPABASE_URL = process.env.ZEST_SUPABASE_URL || \"\";\r\nexport const SUPABASE_ANON_KEY = process.env.ZEST_SUPABASE_ANON_KEY || \"\";\r\n\r\n// Claude project directories\r\nexport const CLAUDE_PROJECTS_DIR = join(homedir(), \".claude\", \"projects\");\r\n\r\n// Filter patterns for commands/messages to exclude from tracking\r\nexport const EXCLUDED_COMMAND_PATTERNS = [\r\n  // Claude Code built-in commands\r\n  /^\\/(add-dir|agents|bashes|bug|clear|compact|config|context|cost|doctor|exit|export|help|hooks|ide|init|install-github-app|login|logout|mcp|memory|model|output-style|permissions|plugin|pr-comments|privacy-settings|release-notes|resume|review|rewind|sandbox|security-review|stats|status|statusline|terminal-setup|todos|usage|vim)\\b/i,\r\n\r\n  // Zest plugin commands (like /zest:status, /zest-dev:status, etc.)\r\n  /^\\/zest[^:\\s]*:/i,\r\n\r\n  // Messages containing Zest command tags (e.g., <command-name>/zest-dev:status</command-name>)\r\n  /<command-name>\\/zest[^<]*<\\/command-name>/i,\r\n\r\n  // Messages containing Zest CLI script paths (e.g., \"node .../dist/commands/sync-cli.js\")\r\n  /node\\s+.*\\/dist\\/commands\\/.*-cli\\.js/i,\r\n];\r\n",
    "/**\r\n * Logging utilities\r\n *\r\n * Handles logging to console and file system\r\n */\r\n\r\nimport { appendFile, mkdir } from \"node:fs/promises\";\r\nimport { dirname } from \"node:path\";\r\nimport { LOG_FILE } from \"../config/constants.js\";\r\n\r\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\r\n\r\nclass Logger {\r\n  private minLevel: LogLevel = \"info\";\r\n\r\n  private levels: Record<LogLevel, number> = {\r\n    debug: 0,\r\n    info: 1,\r\n    warn: 2,\r\n    error: 3,\r\n  };\r\n\r\n  setLevel(level: LogLevel): void {\r\n    this.minLevel = level;\r\n  }\r\n\r\n  private async writeToFile(message: string): Promise<void> {\r\n    try {\r\n      await mkdir(dirname(LOG_FILE), { recursive: true });\r\n      const timestamp = new Date().toISOString();\r\n      await appendFile(LOG_FILE, `[${timestamp}] ${message}\\n`, \"utf-8\");\r\n    } catch (error) {\r\n      // Silently fail - don't crash if we can't write logs\r\n      console.error(\"Failed to write to log file:\", error);\r\n    }\r\n  }\r\n\r\n  private shouldLog(level: LogLevel): boolean {\r\n    return this.levels[level] >= this.levels[this.minLevel];\r\n  }\r\n\r\n  debug(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"debug\")) {\r\n      // Only write to file, don't clutter console\r\n      this.writeToFile(`DEBUG: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  info(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"info\")) {\r\n      // Only write to file, don't clutter console\r\n      this.writeToFile(`INFO: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  warn(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"warn\")) {\r\n      // Show warnings to user\r\n      console.warn(`[Zest:Warn] ${message}`, ...args);\r\n      this.writeToFile(`WARN: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  error(message: string, error?: unknown): void {\r\n    if (this.shouldLog(\"error\")) {\r\n      // Show errors to user\r\n      console.error(`[Zest:Error] ${message}`, error);\r\n      this.writeToFile(\r\n        `ERROR: ${message} ${error instanceof Error ? error.stack : JSON.stringify(error)}`,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport const logger = new Logger();\r\n",
    "/**\r\n * Session management\r\n *\r\n * Handles session persistence, validation, and token refresh\r\n */\r\n\r\nimport { mkdir, readFile, unlink, writeFile } from \"node:fs/promises\";\r\nimport { dirname } from \"node:path\";\r\nimport { PROACTIVE_REFRESH_THRESHOLD_MS, SESSION_FILE, WEB_APP_URL } from \"../config/constants.js\";\r\nimport { logger } from \"../utils/logger.js\";\r\n\r\nexport interface AuthSession {\r\n  accessToken: string;\r\n  refreshToken: string;\r\n  expiresAt: number; // Access token expiration (milliseconds)\r\n  refreshTokenExpiresAt?: number; // Refresh token expiration (milliseconds) - optional for backward compatibility\r\n  userId: string;\r\n  email: string;\r\n  workspaceId?: string;\r\n  workspaceName?: string;\r\n}\r\n\r\n/**\r\n * Load session from file\r\n */\r\nexport async function loadSession(): Promise<AuthSession | null> {\r\n  try {\r\n    const content = await readFile(SESSION_FILE, \"utf-8\");\r\n    const session = JSON.parse(content) as AuthSession;\r\n\r\n    // Validate session structure\r\n    if (\r\n      !session.accessToken ||\r\n      !session.refreshToken ||\r\n      !session.expiresAt ||\r\n      !session.userId ||\r\n      !session.email\r\n    ) {\r\n      logger.warn(\"Invalid session structure, clearing session\");\r\n      await clearSession();\r\n      return null;\r\n    }\r\n\r\n    const now = Date.now();\r\n\r\n    // Check if refresh token is expired (only if expiration is set - many configs have refresh tokens that never expire)\r\n    if (session.refreshTokenExpiresAt && session.refreshTokenExpiresAt < now) {\r\n      logger.warn(\"Refresh token expired, user must re-authenticate\");\r\n      await clearSession();\r\n      return null;\r\n    }\r\n\r\n    // Check if access token is expired\r\n    if (session.expiresAt < now) {\r\n      logger.debug(\"Access token expired, attempting refresh\");\r\n      try {\r\n        return await refreshSession(session);\r\n      } catch (error) {\r\n        logger.warn(\"Failed to refresh session\", error);\r\n        await clearSession();\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return session;\r\n  } catch (error) {\r\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\r\n      // File doesn't exist - not an error\r\n      return null;\r\n    }\r\n    logger.error(\"Failed to load session\", error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Save session to file with secure permissions\r\n */\r\nexport async function saveSession(session: AuthSession): Promise<void> {\r\n  try {\r\n    // Ensure directory exists\r\n    await mkdir(dirname(SESSION_FILE), { recursive: true, mode: 0o700 });\r\n\r\n    // Write session file\r\n    await writeFile(SESSION_FILE, JSON.stringify(session, null, 2), {\r\n      encoding: \"utf-8\",\r\n      mode: 0o600, // Readable/writable by owner only\r\n    });\r\n\r\n    logger.info(\"Session saved successfully\");\r\n  } catch (error) {\r\n    logger.error(\"Failed to save session\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Clear session file\r\n */\r\nexport async function clearSession(): Promise<void> {\r\n  try {\r\n    await unlink(SESSION_FILE);\r\n    logger.info(\"Session cleared successfully\");\r\n  } catch (error) {\r\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\r\n      // File doesn't exist - not an error\r\n      return;\r\n    }\r\n    logger.error(\"Failed to clear session\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Refresh an expired session using the refresh token\r\n */\r\nexport async function refreshSession(session: AuthSession): Promise<AuthSession> {\r\n  try {\r\n    logger.debug(\"Refreshing session\");\r\n\r\n    const response = await fetch(`${WEB_APP_URL}/api/auth/extension/refresh`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({\r\n        refreshToken: session.refreshToken,\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Token refresh failed: ${response.status} ${response.statusText}`);\r\n    }\r\n\r\n    const data = (await response.json()) as {\r\n      accessToken: string;\r\n      refreshToken: string;\r\n      expiresIn: number; // seconds until access token expiration\r\n      refreshTokenExpiresIn?: number; // seconds until refresh token expiration\r\n    };\r\n\r\n    // Use actual expiration from Supabase (convert seconds to milliseconds)\r\n    const now = Date.now();\r\n    const expiresAt = now + data.expiresIn * 1000;\r\n\r\n    // Calculate refresh token expiration (if provided, otherwise keep existing or undefined for \"never expires\")\r\n    const refreshTokenExpiresAt = data.refreshTokenExpiresIn\r\n      ? now + data.refreshTokenExpiresIn * 1000\r\n      : session.refreshTokenExpiresAt; // Keep existing or undefined (never expires)\r\n\r\n    const newSession: AuthSession = {\r\n      ...session,\r\n      accessToken: data.accessToken,\r\n      refreshToken: data.refreshToken,\r\n      expiresAt,\r\n      refreshTokenExpiresAt,\r\n    };\r\n\r\n    logger.debug(\r\n      `Access token will expire in ${data.expiresIn} seconds (${new Date(expiresAt).toISOString()})`,\r\n    );\r\n    if (refreshTokenExpiresAt) {\r\n      logger.debug(`Refresh token will expire at ${new Date(refreshTokenExpiresAt).toISOString()}`);\r\n    } else {\r\n      logger.debug(\"Refresh token does not expire\");\r\n    }\r\n\r\n    await saveSession(newSession);\r\n    logger.info(\"Session refreshed successfully\");\r\n\r\n    return newSession;\r\n  } catch (error) {\r\n    logger.error(\"Failed to refresh session\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Check if user is currently authenticated\r\n */\r\nexport async function isAuthenticated(): Promise<boolean> {\r\n  const session = await loadSession();\r\n  return session !== null && session.expiresAt > Date.now();\r\n}\r\n\r\n/**\r\n * Get current session (refresh if needed)\r\n *\r\n * Proactively refreshes tokens 5 minutes before expiration\r\n */\r\nexport async function getValidSession(): Promise<AuthSession | null> {\r\n  const session = await loadSession();\r\n  if (!session) {\r\n    return null;\r\n  }\r\n\r\n  const now = Date.now();\r\n  const timeUntilExpiration = session.expiresAt - now;\r\n\r\n  // Refresh if expired or expiring soon (within 5 minutes)\r\n  if (timeUntilExpiration < PROACTIVE_REFRESH_THRESHOLD_MS) {\r\n    try {\r\n      logger.debug(\r\n        `Token ${timeUntilExpiration < 0 ? \"expired\" : `expiring in ${Math.round(timeUntilExpiration / 1000)}s`}, refreshing...`,\r\n      );\r\n      return await refreshSession(session);\r\n    } catch (error) {\r\n      logger.warn(\"Failed to refresh session\", error);\r\n      return null; // Can't use expired/expiring session\r\n    }\r\n  }\r\n\r\n  return session;\r\n}\r\n",
    "/**\r\n * Authentication flow implementation\r\n *\r\n * Handles device code flow for Zest authentication (like GitHub CLI)\r\n * No local server needed - works everywhere including WSL, remote servers, etc.\r\n */\r\n\r\nimport open from \"open\";\r\nimport { CLIENT_ID, WEB_APP_URL } from \"../config/constants.js\";\r\nimport { updateClaudeCodeMetadata } from \"../supabase/profile-updater.js\";\r\nimport { fetchUserWorkspaces } from \"../supabase/workspace-fetcher.js\";\r\nimport { logger } from \"../utils/logger.js\";\r\nimport { getPluginVersion } from \"../utils/plugin-version.js\";\r\nimport { type AuthSession, clearSession, loadSession, saveSession } from \"./session-manager.js\";\r\n\r\ninterface DeviceCodeResponse {\r\n  authCode: string; // Secure polling token\r\n  deviceCode: string; // User-friendly code (ABCD-1234)\r\n  verificationUrl: string;\r\n  expiresIn: number;\r\n  interval: number;\r\n}\r\n\r\ninterface DevicePollResponse {\r\n  status: \"pending\" | \"authorized\";\r\n  session?: {\r\n    access_token: string;\r\n    refresh_token: string;\r\n    expires_at?: number; // Unix timestamp (seconds) - access token expiration\r\n    expires_in?: number; // Seconds until access token expiration\r\n    refresh_token_expires_at?: number; // Unix timestamp (seconds) - refresh token expiration\r\n    refresh_token_expires_in?: number; // Seconds until refresh token expiration\r\n    user: {\r\n      id: string;\r\n      email?: string;\r\n      user_metadata: Record<string, unknown>;\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * Start the device code authentication flow\r\n */\r\nexport async function startAuthFlow(): Promise<AuthSession> {\r\n  try {\r\n    logger.info(\"Starting device code authentication flow\");\r\n\r\n    // Step 1: Initiate device code flow\r\n    const deviceCodeData = await initiateDeviceCode();\r\n\r\n    // Step 2: Display code to user and open browser\r\n    displayAuthInstructions(deviceCodeData);\r\n\r\n    // Step 3: Poll for authorization\r\n    const session = await pollForAuthorization(deviceCodeData);\r\n\r\n    // Step 4: Save session\r\n    await saveSession(session);\r\n    logger.info(\"Device code authentication successful\");\r\n\r\n    // Step 5: Update profile metadata\r\n    await updateProfileMetadata(session.userId);\r\n\r\n    // Step 6: Select default workspace\r\n    await selectDefaultWorkspace();\r\n\r\n    return session;\r\n  } catch (error) {\r\n    logger.error(\"Device code authentication failed\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Initiate device code flow - get device code and user code\r\n */\r\nasync function initiateDeviceCode(): Promise<DeviceCodeResponse> {\r\n  try {\r\n    const response = await fetch(`${WEB_APP_URL}/api/auth/device/initiate`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({\r\n        clientId: CLIENT_ID,\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      throw new Error(`Failed to initiate device code: ${response.status} - ${errorText}`);\r\n    }\r\n\r\n    const data = (await response.json()) as DeviceCodeResponse;\r\n    logger.debug(\"Device code initiated successfully\", { deviceCode: data.deviceCode });\r\n\r\n    return data;\r\n  } catch (error) {\r\n    logger.error(\"Failed to initiate device code\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Display authentication instructions to the user\r\n */\r\nfunction displayAuthInstructions(deviceCodeData: DeviceCodeResponse): void {\r\n  // Minimal output to avoid Claude CLI truncation\r\n  console.log(`\\nüîê Enter code in browser: ${deviceCodeData.deviceCode}`);\r\n  console.log(`üì± URL: ${deviceCodeData.verificationUrl}\\n`);\r\n\r\n  // Try to open browser automatically\r\n  try {\r\n    open(deviceCodeData.verificationUrl);\r\n  } catch (error) {\r\n    logger.warn(\"Failed to open browser automatically\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * Poll the API to check if user has authorized the device\r\n */\r\nasync function pollForAuthorization(deviceCodeData: DeviceCodeResponse): Promise<AuthSession> {\r\n  const maxAttempts = Math.floor(deviceCodeData.expiresIn / deviceCodeData.interval);\r\n  let attempts = 0;\r\n\r\n  // Show waiting message once\r\n  console.log(\"‚è≥ Waiting for authorization...\\n\");\r\n\r\n  while (attempts < maxAttempts) {\r\n    attempts++;\r\n\r\n    try {\r\n      const response = await fetch(`${WEB_APP_URL}/api/auth/device/poll`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n        },\r\n        body: JSON.stringify({\r\n          authCode: deviceCodeData.authCode,\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errorData = (await response.json()) as { error?: string };\r\n        throw new Error(errorData.error || \"Polling failed\");\r\n      }\r\n\r\n      const data = (await response.json()) as DevicePollResponse;\r\n\r\n      if (data.status === \"authorized\" && data.session) {\r\n        console.log(\"‚úÖ Authorization successful!\");\r\n        logger.info(\"Device authorized successfully\");\r\n\r\n        const now = Date.now();\r\n\r\n        // Calculate access token expiration time from Supabase session data\r\n        let expiresAt: number;\r\n        if (data.session.expires_at) {\r\n          // Supabase returns expires_at in seconds, convert to milliseconds\r\n          expiresAt = data.session.expires_at * 1000;\r\n        } else if (data.session.expires_in) {\r\n          // Fallback: use expires_in (seconds) to calculate expiration\r\n          expiresAt = now + data.session.expires_in * 1000;\r\n        } else {\r\n          // Default: assume 1 hour expiration (Supabase default)\r\n          expiresAt = now + 3600 * 1000;\r\n          logger.warn(\"No access token expiration info from Supabase, assuming 1 hour\");\r\n        }\r\n\r\n        // Calculate refresh token expiration time (if provided - many configs have refresh tokens that never expire)\r\n        let refreshTokenExpiresAt: number | undefined;\r\n        if (data.session.refresh_token_expires_at) {\r\n          // Supabase returns expires_at in seconds, convert to milliseconds\r\n          refreshTokenExpiresAt = data.session.refresh_token_expires_at * 1000;\r\n        } else if (data.session.refresh_token_expires_in) {\r\n          // Fallback: use expires_in (seconds)\r\n          refreshTokenExpiresAt = now + data.session.refresh_token_expires_in * 1000;\r\n        }\r\n        // If no expiration info provided, leave as undefined (refresh token never expires)\r\n\r\n        logger.debug(`Access token will expire at ${new Date(expiresAt).toISOString()}`);\r\n        if (refreshTokenExpiresAt) {\r\n          logger.debug(\r\n            `Refresh token will expire at ${new Date(refreshTokenExpiresAt).toISOString()}`,\r\n          );\r\n        } else {\r\n          logger.debug(\"Refresh token does not expire\");\r\n        }\r\n\r\n        return {\r\n          accessToken: data.session.access_token,\r\n          refreshToken: data.session.refresh_token,\r\n          expiresAt,\r\n          refreshTokenExpiresAt,\r\n          userId: data.session.user.id,\r\n          email: data.session.user.email || \"\",\r\n          workspaceId: undefined,\r\n        };\r\n      }\r\n\r\n      // Still pending - wait silently and try again\r\n      if (data.status === \"pending\") {\r\n        await new Promise((resolve) => setTimeout(resolve, deviceCodeData.interval * 1000));\r\n        continue;\r\n      }\r\n    } catch (error) {\r\n      // Check if it's an authorization denied error\r\n      if (error instanceof Error && error.message.includes(\"denied\")) {\r\n        throw new Error(\"Authorization denied by user\");\r\n      }\r\n\r\n      // Check if it's an expired error\r\n      if (error instanceof Error && error.message.includes(\"expired\")) {\r\n        throw new Error(\"Device code expired. Please try again.\");\r\n      }\r\n\r\n      // For network errors, log and retry\r\n      logger.warn(\"Polling attempt failed\", error);\r\n      await new Promise((resolve) => setTimeout(resolve, deviceCodeData.interval * 1000));\r\n      continue;\r\n    }\r\n  }\r\n\r\n  throw new Error(\"Authorization timeout - no response received\");\r\n}\r\n\r\n/**\r\n * Update user profile metadata to track Claude Code plugin installation\r\n * Non-blocking - logs warning but doesn't fail authentication flow\r\n */\r\nasync function updateProfileMetadata(userId: string): Promise<void> {\r\n  try {\r\n    const version = getPluginVersion();\r\n    await updateClaudeCodeMetadata(userId, version);\r\n    logger.info(\"Profile metadata updated with Claude Code plugin info\");\r\n  } catch (error) {\r\n    // Non-blocking - log warning but don't fail login\r\n    logger.warn(\"Failed to update profile metadata (non-blocking)\", error);\r\n    // Don't show error to user - this is a background operation\r\n  }\r\n}\r\n\r\n/**\r\n * Select default workspace after authentication\r\n * Auto-selects the first (earliest created) workspace\r\n */\r\nasync function selectDefaultWorkspace(): Promise<void> {\r\n  try {\r\n    logger.info(\"Selecting default workspace\");\r\n\r\n    // Fetch user's workspaces\r\n    const workspaces = await fetchUserWorkspaces();\r\n\r\n    if (workspaces.length === 0) {\r\n      // No workspaces - shouldn't happen as device auth page checks\r\n      // But handle gracefully\r\n      console.log(\"\\n‚ö†Ô∏è  No workspace found\");\r\n      console.log(`   Create one at: ${WEB_APP_URL}/onboarding\\n`);\r\n      return;\r\n    }\r\n\r\n    // Sort by created_at ASC (earliest first)\r\n    workspaces.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\r\n\r\n    const defaultWorkspace = workspaces[0];\r\n\r\n    // Update the session with workspace info\r\n    const session = await loadSession();\r\n    if (session) {\r\n      session.workspaceId = defaultWorkspace.id;\r\n      session.workspaceName = defaultWorkspace.name;\r\n      await saveSession(session);\r\n    }\r\n\r\n    // Show workspace info\r\n    if (workspaces.length === 1) {\r\n      console.log(`üè¢ Workspace: ${defaultWorkspace.name}`);\r\n    } else {\r\n      console.log(`üè¢ Workspace: ${defaultWorkspace.name} (default)`);\r\n      console.log(`   ${workspaces.length - 1} other workspace(s) available`);\r\n      console.log(\"   Run /zest:workspace to switch\");\r\n    }\r\n\r\n    logger.info(\"Default workspace selected\", {\r\n      workspace_id: defaultWorkspace.id,\r\n      workspace_name: defaultWorkspace.name,\r\n      total_workspaces: workspaces.length,\r\n    });\r\n  } catch (error) {\r\n    logger.error(\"Failed to select default workspace\", error);\r\n    // Don't throw - authentication already succeeded\r\n    console.log(\"\\n‚ö†Ô∏è  Could not load workspaces\");\r\n    console.log(\"   Run /zest:workspace later to select one\\n\");\r\n  }\r\n}\r\n\r\n/**\r\n * Logout and clear session\r\n */\r\nexport async function logout(): Promise<void> {\r\n  try {\r\n    await clearSession();\r\n    logger.info(\"Logged out successfully\");\r\n  } catch (error) {\r\n    logger.error(\"Failed to logout\", error);\r\n    throw error;\r\n  }\r\n}\r\n",
    "#!/usr/bin/env node\r\n/**\r\n * /zest:logout command handler\r\n *\r\n * Signs out of Zest and removes stored credentials\r\n */\r\n\r\nimport { logout } from \"../auth/authentication.js\";\r\nimport { loadSession } from \"../auth/session-manager.js\";\r\nimport { logger } from \"../utils/logger.js\";\r\n\r\nasync function main() {\r\n  try {\r\n    // Check if authenticated\r\n    const session = await loadSession();\r\n    if (!session) {\r\n      console.log(\"‚ÑπÔ∏è  Not authenticated\");\r\n      return;\r\n    }\r\n\r\n    const email = session.email;\r\n\r\n    // Logout\r\n    await logout();\r\n\r\n    console.log(`‚úÖ Signed out (${email})`);\r\n  } catch (error) {\r\n    logger.error(\"Logout failed\", error);\r\n    console.error(\"‚ùå Logout failed\");\r\n    if (error instanceof Error) {\r\n      console.error(`   ${error.message}`);\r\n    }\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nmain();\r\n"
  ],
  "mappings": "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",
  "debugId": "53695EFAB35C6DB764756E2164756E21",
  "names": []
}