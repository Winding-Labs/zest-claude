{
  "version": 3,
  "sources": ["../src/config/constants.ts", "../src/auth/statusline-setup.ts", "../src/utils/claude-settings-manager.ts", "../src/utils/fs-utils.ts", "../src/utils/logger.ts", "../src/utils/log-rotation.ts"],
  "sourcesContent": [
    "/**\r\n * Application constants and configuration values\r\n */\r\n\r\nimport { homedir } from \"node:os\";\r\nimport { join } from \"node:path\";\r\n\r\n// Claude Code directories\r\n// Respects CLAUDE_INSTALL_PATH environment variable for non-standard installations\r\nexport const CLAUDE_INSTALL_DIR = process.env.CLAUDE_INSTALL_PATH || join(homedir(), \".claude\");\r\nexport const CLAUDE_PROJECTS_DIR = join(CLAUDE_INSTALL_DIR, \"projects\");\r\nexport const CLAUDE_SETTINGS_FILE = join(CLAUDE_INSTALL_DIR, \"settings.json\");\r\n\r\n// Base directories\r\nexport const CLAUDE_ZEST_DIR = join(CLAUDE_INSTALL_DIR, \"..\", \".claude-zest\");\r\nexport const QUEUE_DIR = join(CLAUDE_ZEST_DIR, \"queue\");\r\nexport const LOGS_DIR = join(CLAUDE_ZEST_DIR, \"logs\");\r\nexport const STATE_DIR = join(CLAUDE_ZEST_DIR, \"state\");\r\nexport const DELETION_CACHE_DIR = join(CLAUDE_ZEST_DIR, \"cache\", \"deletions\");\r\n\r\n// File paths\r\nexport const SESSION_FILE = join(CLAUDE_ZEST_DIR, \"session.json\"); // Auth session + workspace info\r\nexport const SETTINGS_FILE = join(CLAUDE_ZEST_DIR, \"settings.json\"); // User preferences\r\nexport const DAEMON_PID_FILE = join(CLAUDE_ZEST_DIR, \"daemon.pid\");\r\nexport const STATUSLINE_SCRIPT_PATH = join(CLAUDE_ZEST_DIR, \"statusline.mjs\"); // Status line script (.mjs for ESM support)\r\nexport const STATUS_CACHE_FILE = join(CLAUDE_ZEST_DIR, \"status-cache.json\"); // Status cache for version checks and sync errors\r\n\r\n// Queue files\r\nexport const EVENTS_QUEUE_FILE = join(QUEUE_DIR, \"events.jsonl\");\r\nexport const SESSIONS_QUEUE_FILE = join(QUEUE_DIR, \"chat-sessions.jsonl\");\r\nexport const MESSAGES_QUEUE_FILE = join(QUEUE_DIR, \"chat-messages.jsonl\");\r\n\r\n// Platform and source identifiers\r\nexport const PLATFORM = \"terminal\";\r\nexport const SOURCE = \"claude-code\";\r\nexport const CLIENT_ID = \"claude-cli\";\r\n\r\n// Sync configuration\r\nexport const SYNC_INTERVAL_MS = 60000; // 60 seconds\r\nexport const MAX_RETRY_ATTEMPTS = 3;\r\nexport const RETRY_BACKOFF_MS = 5000;\r\n\r\n// File locking configuration\r\nexport const LOCK_RETRY_MS = 50; // Retry interval when lock is held by another process\r\nexport const LOCK_MAX_RETRIES = 300; // Max retries (10 seconds total)\r\n\r\n// Debounce configuration (prevents duplicate hook executions)\r\nexport const DEBOUNCE_DIR = join(CLAUDE_ZEST_DIR, \"debounce\");\r\nexport const DEBOUNCE_WINDOW_MS = 500; // First-wins debounce window\r\nexport const DEBOUNCE_TRAILING_MS = 300; // Trailing debounce: wait after last hook before processing\r\n\r\n// Delayed extraction configuration (for PostToolUse trailing debounce)\r\nexport const DELAYED_EXTRACTION_INITIAL_DELAY_MS = 500; // Initial wait before checking if hooks settled\r\nexport const DELAYED_EXTRACTION_MAX_WAIT_MS = 10000; // Maximum total wait time\r\nexport const DELAYED_EXTRACTION_CHECK_INTERVAL_MS = 300; // How often to check if hooks settled\r\n\r\n// Cache configuration\r\nexport const DELETION_CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\r\n\r\n// Log rotation configuration\r\nexport const LOG_RETENTION_DAYS = 7; // Delete log files older than 7 days\r\n\r\n// Authentication configuration\r\nexport const PROACTIVE_REFRESH_THRESHOLD_MS = 5 * 60 * 1000; // Proactively refresh JWT/access tokens 5 minutes before expiration\r\n\r\n// Content size limits\r\nexport const MAX_DIFF_SIZE_BYTES = 10 * 1024 * 1024; // 10MB\r\nexport const MAX_CONTENT_PREVIEW_LENGTH = 1000; // characters\r\nexport const MAX_SESSION_TITLE_LENGTH = 100; // characters\r\nexport const MIN_SESSION_TITLE_LENGTH = 3; // characters\r\n\r\n// Session quality filters\r\nexport const MIN_MESSAGES_PER_SESSION = 3; // Minimum messages required to upload a session\r\nexport const STALE_SESSION_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\r\n\r\n// API endpoints (configured from .env at build time)\r\n// Values are baked into the bundle during build\r\nexport const WEB_APP_URL = process.env.ZEST_WEB_APP_URL || \"http://localhost:3000\";\r\nexport const SUPABASE_URL = process.env.ZEST_SUPABASE_URL || \"\";\r\nexport const SUPABASE_ANON_KEY = process.env.ZEST_SUPABASE_ANON_KEY || \"\";\r\n\r\n// PostHog analytics (configured from .env at build time)\r\nexport const POSTHOG_API_KEY = process.env.POSTHOG_API_KEY || \"\";\r\n\r\n// Filter patterns for commands/messages to exclude from tracking\r\nexport const EXCLUDED_COMMAND_PATTERNS = [\r\n  // Claude Code built-in commands\r\n  /^\\/(add-dir|agents|bashes|bug|clear|compact|config|context|cost|doctor|exit|export|help|hooks|ide|init|install-github-app|login|logout|mcp|memory|model|output-style|permissions|plugin|pr-comments|privacy-settings|release-notes|resume|review|rewind|sandbox|security-review|stats|status|statusline|terminal-setup|todos|usage|vim)\\b/i,\r\n\r\n  // Zest plugin commands (like /zest:status, /zest:login, etc.)\r\n  /^\\/zest[^:\\s]*:/i,\r\n\r\n  // Messages containing Zest command tags (e.g., <command-name>/zest:status</command-name>)\r\n  /<command-name>\\/zest[^<]*<\\/command-name>/i,\r\n\r\n  // Messages containing Zest CLI script paths (e.g., \"node .../dist/commands/sync-cli.js\")\r\n  /node\\s+.*\\/dist\\/commands\\/.*-cli\\.js/i,\r\n];\r\n\r\nexport const ZEST_SESSION_NAMESPACE = \"1b671a64-40d5-491e-99b0-da01ff1f3341\";\r\n\r\n// Version check configuration\r\n// If ZEST_MARKETPLACE_PLUGIN_JSON_URL is not set, version checking will be disabled\r\nexport const MARKETPLACE_PLUGIN_JSON_URL = process.env.ZEST_MARKETPLACE_PLUGIN_JSON_URL || \"\";\r\nexport const VERSION_CHECK_TIMEOUT_MS = 5000; // 5 seconds\r\nexport const UPDATE_CHECK_CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour - how long to cache update check results\r\n\r\n// Daemon management configuration\r\nexport const DAEMON_FRESH_PID_THRESHOLD_MS = 2000; // 2 seconds - how recently PID file must be modified to skip restart\r\n",
    "/**\r\n * Status Line Setup Orchestrator\r\n *\r\n * Handles automatic status line configuration during authentication\r\n * Called after successful authentication to configure Claude Code's status line\r\n */\r\n\r\nimport { STATUSLINE_SCRIPT_PATH } from \"../config/constants.js\";\r\nimport {\r\n  getStatusLineConfig,\r\n  hasStatusLineConfigured,\r\n  setZestStatusLine,\r\n} from \"../utils/claude-settings-manager.js\";\r\nimport { logger } from \"../utils/logger.js\";\r\n\r\n/**\r\n * Check and configure status line after successful authentication\r\n *\r\n * Three scenarios:\r\n * 1. No settings file or no statusLine ‚Üí Configure automatically\r\n * 2. StatusLine already configured (not Zest) ‚Üí Show informational message\r\n * 3. Zest statusLine already configured ‚Üí Silent (nothing to do)\r\n *\r\n * This function never throws - all errors are caught and logged\r\n */\r\nexport async function setupStatusLineAfterAuth(): Promise<void> {\r\n  try {\r\n    logger.info(\"Starting status line setup after authentication\");\r\n\r\n    // Check current status line configuration\r\n    const hasStatusLine = await hasStatusLineConfigured();\r\n    const currentConfig = await getStatusLineConfig();\r\n\r\n    // Scenario 1: No status line configured ‚Üí Auto-configure\r\n    if (!hasStatusLine) {\r\n      logger.info(\"No status line configured, setting up Zest status line\");\r\n      await setZestStatusLine();\r\n      console.log(\"‚úÖ Status line configured for update notifications\");\r\n      console.log(\"   üçã Updates will appear at the bottom of Claude Code\");\r\n      return;\r\n    }\r\n\r\n    // Scenario 2: Status line configured, but not Zest ‚Üí Inform user\r\n    // Check if current command matches Zest statusline (by path or script name)\r\n    const isZestStatusLine = currentConfig?.command === STATUSLINE_SCRIPT_PATH;\r\n\r\n    if (!isZestStatusLine) {\r\n      logger.info(\"Different status line already configured\", {\r\n        currentCommand: currentConfig?.command,\r\n      });\r\n      console.log(\"\\nüìä Update Notification Feature Available\");\r\n      console.log(\"   Zest can show plugin updates in your status line\");\r\n      console.log(\"   Current status line: \" + currentConfig?.command);\r\n      console.log(\"\");\r\n      console.log(\"   To enable Zest notifications, run: /zest:enable-statusline\");\r\n      console.log(\"   (Note: This will replace your current status line)\\n\");\r\n      return;\r\n    }\r\n\r\n    // Scenario 3: Zest status line already configured ‚Üí Silent\r\n    logger.debug(\"Zest status line already configured, no action needed\");\r\n  } catch (error) {\r\n    // Non-blocking: Log error but don't fail authentication\r\n    logger.error(\"Failed to setup status line\", error);\r\n    logger.debug(\"Authentication continues despite status line setup failure\");\r\n\r\n    // Brief user-facing message (not alarming)\r\n    console.log(\"\\n‚ö†Ô∏è  Note: Could not configure status line automatically\");\r\n    console.log(\"   You can enable it later with: /zest:enable-statusline\\n\");\r\n  }\r\n}\r\n",
    "/**\r\n * Claude Code Settings Manager\r\n *\r\n * Handles reading and writing Claude Code's settings.json file\r\n * Uses CLAUDE_INSTALL_PATH environment variable if set, otherwise defaults to ~/.claude\r\n * Used for configuring status line and other Claude Code settings\r\n */\r\n\r\nimport { readFile, writeFile } from \"node:fs/promises\";\r\nimport { CLAUDE_INSTALL_DIR, CLAUDE_SETTINGS_FILE } from \"../config/constants.js\";\r\nimport { ensureDirectory } from \"./fs-utils.js\";\r\nimport { logger } from \"./logger.js\";\r\n\r\nexport interface ClaudeSettings {\r\n  statusLine?: {\r\n    type: string;\r\n    command: string;\r\n  };\r\n  [key: string]: any; // Preserve other settings\r\n}\r\n\r\n/**\r\n * Read Claude Code settings.json file\r\n * Returns null if file doesn't exist\r\n * Throws error if file exists but is malformed\r\n */\r\nexport async function readClaudeSettings(): Promise<ClaudeSettings | null> {\r\n  try {\r\n    const content = await readFile(CLAUDE_SETTINGS_FILE, \"utf-8\");\r\n    const settings = JSON.parse(content) as ClaudeSettings;\r\n    logger.debug(\"Claude settings read successfully\", { path: CLAUDE_SETTINGS_FILE });\r\n    return settings;\r\n  } catch (error) {\r\n    if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\r\n      // File doesn't exist - not an error\r\n      logger.debug(\"Claude settings file does not exist\", { path: CLAUDE_SETTINGS_FILE });\r\n      return null;\r\n    }\r\n\r\n    // JSON parse error or other file read error\r\n    logger.error(\"Failed to read Claude settings\", {\r\n      path: CLAUDE_SETTINGS_FILE,\r\n      error: error instanceof Error ? error.message : String(error),\r\n    });\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Write Claude Code settings.json file\r\n * Creates Claude install directory if it doesn't exist\r\n * Preserves all existing settings, only updates what's provided\r\n */\r\nexport async function writeClaudeSettings(settings: ClaudeSettings): Promise<void> {\r\n  try {\r\n    // Ensure Claude install directory exists\r\n    await ensureDirectory(CLAUDE_INSTALL_DIR);\r\n\r\n    // Read existing settings to merge\r\n    const existingSettings = (await readClaudeSettings()) || {};\r\n\r\n    // Merge new settings with existing (new settings take precedence)\r\n    const mergedSettings = { ...existingSettings, ...settings };\r\n\r\n    // Write back to file with pretty formatting\r\n    await writeFile(CLAUDE_SETTINGS_FILE, JSON.stringify(mergedSettings, null, 2), \"utf-8\");\r\n\r\n    logger.info(\"Claude settings updated successfully\", {\r\n      path: CLAUDE_SETTINGS_FILE,\r\n      updatedKeys: Object.keys(settings),\r\n    });\r\n  } catch (error) {\r\n    logger.error(\"Failed to write Claude settings\", {\r\n      path: CLAUDE_SETTINGS_FILE,\r\n      error: error instanceof Error ? error.message : String(error),\r\n    });\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Check if status line is configured in Claude Code settings\r\n * Returns true if statusLine key exists with any value\r\n */\r\nexport async function hasStatusLineConfigured(): Promise<boolean> {\r\n  try {\r\n    const settings = await readClaudeSettings();\r\n    const hasStatusLine = settings?.statusLine !== undefined;\r\n    logger.debug(\"Status line configuration check\", { hasStatusLine });\r\n    return hasStatusLine;\r\n  } catch (error) {\r\n    logger.warn(\"Error checking status line configuration\", error);\r\n    return false; // Assume not configured on error\r\n  }\r\n}\r\n\r\n/**\r\n * Get current status line configuration\r\n * Returns the statusLine object if configured, null otherwise\r\n */\r\nexport async function getStatusLineConfig(): Promise<ClaudeSettings[\"statusLine\"] | null> {\r\n  try {\r\n    const settings = await readClaudeSettings();\r\n    const statusLineConfig = settings?.statusLine || null;\r\n    logger.debug(\"Status line config retrieved\", { config: statusLineConfig });\r\n    return statusLineConfig;\r\n  } catch (error) {\r\n    logger.warn(\"Error getting status line configuration\", error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Set Zest status line configuration\r\n * Preserves all other settings\r\n *\r\n * Note: Uses absolute path for cross-platform compatibility\r\n * Claude Code will execute this script to render the status line\r\n */\r\nexport async function setZestStatusLine(): Promise<void> {\r\n  const { STATUSLINE_SCRIPT_PATH } = await import(\"../config/constants.js\");\r\n\r\n  const zestStatusLineConfig: ClaudeSettings = {\r\n    statusLine: {\r\n      type: \"command\",\r\n      command: STATUSLINE_SCRIPT_PATH,\r\n    },\r\n  };\r\n\r\n  try {\r\n    await writeClaudeSettings(zestStatusLineConfig);\r\n    logger.info(\"Zest status line configured successfully\", {\r\n      scriptPath: STATUSLINE_SCRIPT_PATH,\r\n    });\r\n  } catch (error) {\r\n    logger.error(\"Failed to set Zest status line\", error);\r\n    throw error;\r\n  }\r\n}\r\n",
    "/**\r\n * Filesystem utility functions\r\n *\r\n * Shared helpers for file and directory operations\r\n *\r\n * Note: This module intentionally has no dependencies on logger.ts\r\n * to avoid circular dependencies (logger.ts uses ensureDirectory).\r\n */\r\n\r\nimport { mkdir, stat } from \"node:fs/promises\";\r\n\r\n/**\r\n * Ensure directory exists, creating it if necessary\r\n * Creates parent directories recursively with secure permissions (mode 0o700)\r\n *\r\n * @param dirPath - Path to the directory to ensure exists\r\n */\r\nexport async function ensureDirectory(dirPath: string): Promise<void> {\r\n  try {\r\n    await stat(dirPath);\r\n  } catch {\r\n    await mkdir(dirPath, { recursive: true, mode: 0o700 });\r\n  }\r\n}\r\n",
    "/**\r\n * Logging utilities\r\n *\r\n * Handles logging to console and file system with daily log rotation.\r\n * Log files are named with dates (e.g., plugin-2026-01-09.log) and\r\n * automatically cleaned up after LOG_RETENTION_DAYS.\r\n */\r\n\r\nimport { appendFile } from \"node:fs/promises\";\r\nimport { dirname } from \"node:path\";\r\nimport { ensureDirectory } from \"./fs-utils.js\";\r\nimport { cleanupStaleLogs, getDatedLogPath } from \"./log-rotation.js\";\r\n\r\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\r\n\r\nclass Logger {\r\n  private minLevel: LogLevel = \"info\";\r\n  private readonly logPrefix: string;\r\n\r\n  private levels: Record<LogLevel, number> = {\r\n    debug: 0,\r\n    info: 1,\r\n    warn: 2,\r\n    error: 3,\r\n  };\r\n\r\n  constructor(logPrefix = \"plugin\") {\r\n    this.logPrefix = logPrefix;\r\n  }\r\n\r\n  setLevel(level: LogLevel): void {\r\n    this.minLevel = level;\r\n  }\r\n\r\n  private async writeToFile(message: string): Promise<void> {\r\n    try {\r\n      // Get date-based log path (handles date rollover automatically)\r\n      const logFilePath = getDatedLogPath(this.logPrefix);\r\n      await ensureDirectory(dirname(logFilePath));\r\n      const timestamp = new Date().toISOString();\r\n      await appendFile(logFilePath, `[${timestamp}] ${message}\\n`, \"utf-8\");\r\n\r\n      // Trigger cleanup (throttled to once per hour)\r\n      cleanupStaleLogs(this.logPrefix);\r\n    } catch (error) {\r\n      // Silently fail - don't crash if we can't write logs\r\n      console.error(\"Failed to write to log file:\", error);\r\n    }\r\n  }\r\n\r\n  private shouldLog(level: LogLevel): boolean {\r\n    return this.levels[level] >= this.levels[this.minLevel];\r\n  }\r\n\r\n  debug(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"debug\")) {\r\n      // Only write to file, don't clutter console\r\n      this.writeToFile(`DEBUG: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  info(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"info\")) {\r\n      // Only write to file, don't clutter console\r\n      this.writeToFile(`INFO: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  warn(message: string, ...args: unknown[]): void {\r\n    if (this.shouldLog(\"warn\")) {\r\n      // Show warnings to user\r\n      console.warn(`[Zest:Warn] ${message}`, ...args);\r\n      this.writeToFile(`WARN: ${message} ${args.length > 0 ? JSON.stringify(args) : \"\"}`);\r\n    }\r\n  }\r\n\r\n  error(message: string, error?: unknown): void {\r\n    if (this.shouldLog(\"error\")) {\r\n      // Show errors to user\r\n      console.error(`[Zest:Error] ${message}`, error);\r\n      this.writeToFile(\r\n        `ERROR: ${message} ${error instanceof Error ? error.stack : JSON.stringify(error)}`,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport const logger = new Logger();\r\n",
    "/**\r\n * Log rotation utilities\r\n *\r\n * Provides date-based log file paths and automatic cleanup of stale logs.\r\n */\r\n\r\nimport { readdir, unlink } from \"node:fs/promises\";\r\nimport { join } from \"node:path\";\r\nimport { LOG_RETENTION_DAYS, LOGS_DIR } from \"../config/constants.js\";\r\nimport { ensureDirectory } from \"./fs-utils.js\";\r\nimport { logger } from \"./logger.js\";\r\n\r\n// Throttle cleanup to run at most once per hour\r\nconst CLEANUP_THROTTLE_MS = 60 * 60 * 1000; // 1 hour\r\nlet lastCleanupTime: Record<string, number> = {};\r\n\r\n/**\r\n * Get current date string in YYYY-MM-DD format (UTC)\r\n */\r\nexport function getDateString(): string {\r\n  return new Date().toISOString().split(\"T\")[0];\r\n}\r\n\r\n/**\r\n * Get date-based log file path\r\n * @param logPrefix - Prefix for the log file (e.g., \"plugin\" or \"sync\")\r\n * @returns Full path like ~/.claude-zest/logs/plugin-2026-01-09.log\r\n */\r\nexport function getDatedLogPath(logPrefix: string): string {\r\n  const dateStr = getDateString();\r\n  return join(LOGS_DIR, `${logPrefix}-${dateStr}.log`);\r\n}\r\n\r\n/**\r\n * Parse date from log filename\r\n * @param filename - Filename like \"plugin-2026-01-09.log\"\r\n * @param logPrefix - Prefix to match (e.g., \"plugin\")\r\n * @returns Date object or null if doesn't match pattern\r\n */\r\nfunction parseDateFromFilename(filename: string, logPrefix: string): Date | null {\r\n  const pattern = new RegExp(`^${logPrefix}-(\\\\d{4}-\\\\d{2}-\\\\d{2})\\\\.log$`);\r\n  const match = filename.match(pattern);\r\n\r\n  if (!match) {\r\n    return null;\r\n  }\r\n\r\n  const date = new Date(match[1] + \"T00:00:00Z\");\r\n  return Number.isNaN(date.getTime()) ? null : date;\r\n}\r\n\r\n/**\r\n * Clean up stale log files older than retention period\r\n * Throttled to run at most once per hour per logPrefix\r\n *\r\n * @param logPrefix - Prefix of logs to clean (e.g., \"plugin\" or \"sync\")\r\n */\r\nexport async function cleanupStaleLogs(logPrefix: string): Promise<void> {\r\n  const now = Date.now();\r\n  const lastCleanup = lastCleanupTime[logPrefix] || 0;\r\n\r\n  // Throttle: skip if cleaned up less than an hour ago\r\n  if (now - lastCleanup < CLEANUP_THROTTLE_MS) {\r\n    return;\r\n  }\r\n\r\n  lastCleanupTime[logPrefix] = now;\r\n\r\n  try {\r\n    await ensureDirectory(LOGS_DIR);\r\n    const files = await readdir(LOGS_DIR);\r\n    const cutoffDate = new Date(now - LOG_RETENTION_DAYS * 24 * 60 * 60 * 1000);\r\n\r\n    for (const file of files) {\r\n      const fileDate = parseDateFromFilename(file, logPrefix);\r\n\r\n      if (fileDate && fileDate < cutoffDate) {\r\n        const filePath = join(LOGS_DIR, file);\r\n        try {\r\n          await unlink(filePath);\r\n        } catch (error) {\r\n          logger.error(`Failed to delete old log file ${file}`, error);\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    logger.error(\"Failed to cleanup old logs\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * Force cleanup regardless of throttle (for daemon startup)\r\n * @param logPrefix - Prefix of logs to clean (e.g., \"plugin\" or \"sync\")\r\n */\r\nexport async function forceCleanupStaleLogs(logPrefix: string): Promise<void> {\r\n  // Reset throttle to force cleanup\r\n  lastCleanupTime[logPrefix] = 0;\r\n  await cleanupStaleLogs(logPrefix);\r\n}\r\n"
  ],
  "mappings": "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",
  "debugId": "1E4F8223DF72653D64756E2164756E21",
  "names": []
}